[{"title":"B-树 && B+树","url":"/2020/04/08/B-树和B+树/","content":"\n# 头疼的B树以及强大的作用\n\n## B-树\n\ntip: B-树非B减树，而就是B树\n\nB树是一种多路平衡查找树，它的每一个节点最多包含k个孩子，k为B树的阶。K取决于磁盘页的大小\n\n---\n\n一个m阶的B树的特征：\n\n1. 根结点至少有两个子女\n2. 每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m\n3. 每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m\n4. 所有的叶子结点都位于同一层\n5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划\n\n**以一个3阶B-树为例**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlr4mz496j30hs07eglf.jpg)\n\n查询5过程：\n\n<center>第1次磁盘IO：</center>\n\n<div align=center><img src =\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlr6c2x59j30hs07mjr7.jpg\"/></div>\n\n<center>在内存中定位（和9比较）：</center>\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlrg7nd1tj30hs07fweb.jpg\"/></div>\n\n<center>第2次磁盘IO：</center>\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlrck54kbj30hs078glf.jpg\"/></div>\n\n<center>在内存中定位（和2，6比较）：</center>\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlre70t02j30hs07ct8j.jpg\"/></div>\n\n\n\n<center>第3次磁盘IO：</center>\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlrck54kbj30hs078glf.jpg\"/></div>\n\n\n\n<center>在内存中定位（和3，5比较）：</center>\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlrb4s9bhj30hs07g0sk.jpg\"/></div>\n\n虽然看着比较次数比二叉查找树的次数还多，但是进行磁盘IO的次数少了，效率取决于磁盘IO的次数[click](#reason)\n\n**B-树的作用**\n\n- 文件系统以及部分数据库索引，如MongoDB\n\n## B+树\n\nB+树是基于B-树的一种变体，有着比B-树更高的查询性能\n\n在B-树的基础上，一个m阶的B+树有新的特征：\n\n1. 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点\n\n2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接\n3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素\n\n<div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlrz7ikgzj30hs0723yc.jpg\"/></div>\n\n**卫星数据：索引元素所指向的数据记录**\n\n- 在B-树中，无论是中间节点还是叶子节点都带有卫星数据\n\n  <div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdls372f3gj30hs08ma9z.jpg\"/></div>\n\n- 在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联\n\n  <div align=center><img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdls4jese7j30hs085mx2.jpg\"/></div>\n\n**优点**：主要体现在查询性能上\n\n- 单行查询\n  - B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳能多的节点元素，在数据量相同的情况下，B+树比B-树更加的“矮胖”，查询时IO次数更少\n  - B+树更加的稳定，最终肯定在叶子节点匹配到元素；而B-树则可能在中间节点也可能在叶子节点匹配到元素\n- 范围查询\n  - B-树的范围查询很繁琐，只能通过中序遍历来确定范围\n  - B+树由于叶子节点有指向下一个结点的指针，所以只需在链表上做遍历确定范围即可\n\n**作用**\n\n- MySQL数据库的索引用的就是B+树结构\n\n## B+树相比于B-树的优点\n\n1. **IO次数少：**单一节点存储更多的元素，使得查询的IO次数更少\n2. **查询性能稳定：**所有查询都要查找到叶子节点，查询性能稳定\n3. **范围查询简便：**所有叶子节点形成有序链表，便于范围查询\n\n## 索引\n\n### 1. 数据库索引为什么要使用树结构存储？\n\n输的查询效率高，且有序？？（既然这样，为何不使用二叉查找树来实现？？）\n\n**在选择数据库索引的数据结构时，我们不得不考虑一个很现实的问题：磁盘IO**<span id=\"reason\" />\n\n- 数据库的索引是存储在磁盘上的，当索引比较大的时候，可能有几个G甚至更多\n- 我们在利用索引查询时，不可能把整个索引都加载到内存\n- 我们可以做的是逐一加载每一个磁盘页，这里的磁盘页对应着索引树的节点。每一个磁盘页对应着一个索引树的节点\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlqpt5p1tj30hs0e6mx0.jpg)\n\n在我们每次和树中的结点比较时，都需要进行一次IO操作，将结点内的数据加载到内存中进行比较\n\nIO和在内存中比较这两个操作相比，在内存中比较的时间可以忽略不计\n\n所以为了减少磁盘IO的次数，我们需要把原本“瘦高”的树结构变得“矮胖”\n\n这也是不选择二叉查找树，而选择B-的原因\n\n\n\n","tags":["算法"],"categories":["面试"]},{"title":"Lambda","url":"/2020/04/07/Lambda/","content":"\n# Java8 新特性 Lambda\n\n## 什么是 Lambda？\n\n**“Lambda 表达式” 是一个匿名函数**\n\n给一个 Java 变量赋值\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdli4ohs46j30gq05ot8o.jpg)\n\n但是如果你想把一个代码块赋给一个 Java 变量，怎么做到呢？\n\n比如，把右边的那块代码，赋给左边的叫做 aBlockOfCode 的变量：\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdli5rnh7dj30eu03pt8m.jpg)\n\n当然这还不算最简洁的写法，为了使代码更简练，我们可以做以下操作，移除没用的声明\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdli6guxyjj30hs0jkjs4.jpg)\n\n这样，我们成功优雅地把一个代码块赋给了一个变量。**而这个代码块，或者说这个被赋给一个变量的函数，就是一个 Lambda 表达式**。\n\n但这里仍然存在一个问题，那就是变量 aBlockOfCode 的类型应该是什么？\n\n在 Java 8 里面，**所有的 Lambda 的类型都是一个接口，而 Lambda 表达式本身，也就是那个代码块，需要是这个接口的实现。**这是我认为理解 Lambda 的一个关键点所在，简言之，**Lambda 表达式本身就是一个接口的实现**。这样说可能还是有些困惑，继续举例。\n\n我们给 aBlockOfCode 加上一个类型：\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlia27upjj30eu06sdfv.jpg)\n\n这种只有**一个接口函数需要被实现的接口类型，我们叫它\"函数式接口\"。**为了避免后来的人在这个接口中增加接口函数导致其有多个接口函数需要被实现，变成\"非函数接口”，我们可以加上一个声明@FunctionalInterface, 这样别人就没有办法在里面添加新的接口函数了：\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdliatukrqj308u03fjra.jpg)\n\n这样，我们就得到了一个完整的 Lambda 表达式声明：\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlibc6l5ej30k00273ye.jpg)\n\n## Lambda 表达式有什么作用？\n\n最直观的作用就是使得代码变得非常简洁。\n\n我们可以对比一下 Lambda 表达式和传统的 Java 对同一个接口的实现：\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlid1qqf2j30hs063glm.jpg)\n\n这两种写法本质上是一样的。但是很明显，Java 8 中的写法更加优雅简洁。并且，由于 Lambda 可以直接赋值给一个变量，我们就可以直接把 Lambda 作为参数传给函数, 而传统的 Java 必须有明确的接口实现的定义，初始化才可以：\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlifa1bbgj30hs07yq33.jpg)\n\n有些情况下，这个接口实现只需要用到一次。传统的 Java 7 要求你必须定义一个“污染环境”的接口实现 MyInterfaceImpl，相对而言 Java 8 的 Lambda, 就显得干净很多。\n\n## Lambda 结合 FunctionalInterface Lib, forEach, stream()，method reference 等新特性可以使代码变的更加简洁！\n\n举例说明：\n\n假设 Person 的定义和 List<Person>的值都给定。\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlih73ui0j30hs062mxc.jpg)\n\n现在需要你打印出 guiltyPersons List 里面所有 LastName 以\"Z\"开头的人的 FirstName。\n\n原生态 Lambda 写法：定义两个函数式接口，定义一个静态函数，调用静态函数并给参数赋值 Lambda 表达式。\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlihtsvrsj30gb0cpwf6.jpg)\n\n这个代码实际上已经比较简洁了，但是我们还可以更简洁么？\n\n当然可以。在 Java 8 中有一个函数式接口的包，里面定义了大量可能用到的函数式接口（java.util.function (Java Platform SE 8 )）。所以，我们在这里压根都不需要定义 NameChecker 和 Executor 这两个函数式接口，直接用 Java 8 函数式接口包里的 Predicate<T>和 Consumer<T>就可以了——因为他们这一对的接口定义和 NameChecker/Executor 其实是一样的。\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdliicgkugj30fb06vaac.jpg)\n\n**第一步简化 - 利用函数式接口包：**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdliknu4h2j30gx08zt95.jpg)\n\n静态函数里面的 for each 循环其实是非常碍眼的。这里可以利用 Iterable 自带的 forEach()来替代。forEach()本身可以接受一个 Consumer<T> 参数。\n\n**第二步简化 - 用 Iterable.forEach()取代 foreach loop：**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlikxjo9ij30gu07ot96.jpg)\n\n由于静态函数其实只是对 List 进行了一通操作，这里我们可以甩掉静态函数，直接使用 stream()特性来完成。stream()的几个方法都是接受 Predicate<T>，Consumer<T>等参数的（java.util.stream (Java Platform SE 8 )）。你理解了上面的内容，stream()这里就非常好理解了，并不需要多做解释。\n\n**第三步简化 - 利用 stream()替代静态函数：**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlik71ihjj30e3038q2x.jpg)\n\n对比最开始的 Lambda 写法，这里已经非常非常简洁了。但是如果，我们的要求变一下，变成 print 这个人的全部信息，即 p -> System.out.println(p); 那么还可以利用 Method reference 来继续简化。所谓 Method reference, 就是用已经写好的别的 Object/Class 的 method 来代替 Lambda expression。格式如下：\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlijvuc2hj30cr024744.jpg)\n\n**第四步简化 - 如果是 println(p)，则可以利用 Method reference 代替 forEach 中的 Lambda 表达式：**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlijm81blj30ch02wq2w.jpg)\n\n这基本上就是能写的最简洁的版本了。\n\n## Lambda 配合 Optional<T>可以使 Java 对于 null 的处理变的异常优雅\n\n这里假设我们有一个 person object，以及一个 person object 的 Optional wrapper:\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlilzaa33j30ez03qgll.jpg)\n\nOptional<T>如果不结合 Lambda 使用的话，并不能使原来繁琐的 null check 变的简单。\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlimdsffdj30ij0513ym.jpg)\n\n**只有当 Optional 结合 Lambda 一起使用的时候，才能发挥出其真正的威力！**\n\n我们现在就来对比一下下面四种常见的 null 处理中，Java 8 的 Lambda+Optional<T>和传统 Java 两者之间对于 null 的处理差异。\n\n**情况一 - 存在则开干**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlimth7t8j30k004ajrb.jpg)\n\n**情况二 - 存在则返回，无则返回屁**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlinau4y3j30k004ljrc.jpg)\n\n**情况三 - 存在则返回，无则由函数产生**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlinpshn5j30k003jaa0.jpg)\n\n**情况四 - 夺命连环 null 检查**\n\n![640.webp](http://ww1.sinaimg.cn/large/005HBDIygy1gdlio5pxmrj30k006d3yl.jpg)\n\n由上述四种情况可以清楚地看到，Optional<T>+Lambda 可以让我们少写很多 ifElse 块。尤其是对于情况四那种夺命连环 null 检查，传统 java 的写法显得冗长难懂，而新的 Optional<T>+Lambda 则清新脱俗，清楚简洁。\n","tags":["面试"],"categories":["面试"]},{"title":"单例模式的五种实现方法","url":"/2020/04/06/单例模式的五种实现方法/","content":"\n```java\n/**\n * @ClassName: Main\n * @Description: TODO\n * @Author: LFool\n * @Date: 2020/4/6 14:44\n * @Version: 1.0\n */\npublic class Main {\n    public static void main(String[] args) {\n        Singleton5.show();\n        Singleton5 instance = Singleton5.getInstance();\n    }\n}\n\n\n/* 饿汉模式 */\nclass Singleton1 {\n    private final static Singleton1 instance = new Singleton1();\n\n    public Singleton1() {\n    }\n\n    public static Singleton1 getInstance() {\n        return instance;\n    }\n}\n\n/* 懒汉模式（线程不安全） */\nclass Singleton2 {\n    private static Singleton2 instance = null;\n\n    public Singleton2() {\n    }\n\n    public static Singleton2 getInstance() {\n        if (instance == null) {\n            instance = new Singleton2();\n        }\n        return instance;\n    }\n}\n\n/* 懒汉模式（线程安全） */\nclass Singleton3 {\n    private static Singleton3 instance = null;\n\n    public Singleton3() {\n    }\n\n    public static synchronized Singleton3 getInstance() {\n        if (instance == null) {\n            instance = new Singleton3();\n        }\n        return instance;\n    }\n}\n\n/* 双重校验模式 */\nclass Singleton4 {\n    private static volatile Singleton4 instance = null;\n\n    public Singleton4() {\n    }\n\n    public static Singleton4 getInstance() {\n        if (instance == null) {\n            synchronized (Singleton4.class) {\n                if (instance == null) {\n                    instance = new Singleton4();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n/* 静态内部类模式 */\nclass Singleton5 {\n    public Singleton5() {\n    }\n\n    public static Singleton5 getInstance() {\n        return SingletonHolder.instance;\n    }\n\n    public static void show() {\n        System.out.println(\"test......\");\n    }\n\n    private static class SingletonHolder {\n\n        static {\n            System.out.println(\"加载。。。\");\n        }\n\n        private static final Singleton5 instance = new Singleton5();\n    }\n}\n```\n","tags":["面试"],"categories":["面试"]},{"title":"volatile","url":"/2020/04/06/volatile/","content":"\n# volatile 关键字\n\n## 两个特点\n\n1. 保证了不同线程对该变量操作的内存立即可见\n2. 禁止指令重排序\n\n## 内存立即可见\n\nJMM 规定：\n\n- 所有变量都存在主内存中（相当于普通内存）\n\n- 每个线程又有自己的工作内存（相当于 CPU 上的寄存器或者高速缓存）\n\n  <img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlizc2kd7j30ii0ivmx5.jpg\" alt=\"(3OA5JQ{0SEX0$Q~DW0T{8A.png\" style=\"zoom: 33%;\" />\n\n  <img src=\"http://ww1.sinaimg.cn/large/005HBDIygy1gdlj0fkmu0j30if0iq748.jpg\" alt=\"9L18~B(`6R~E1}VEK0@5Y1B.png\" style=\"zoom: 33%;\" />\n\n每个线程只能访问自己的工作内存，工作完成后把值同步回主内存中\n\n- 在线程执行时，从主内存中 read 变量值\n- 线程再 load 到工作内存中的副本中\n- 传给线程去处理\n- 处理完成后再给工作内存中的副本复制\n- 工作内存再把值传回给主内存，进行更新\n\n**问题：**当有多个线程执行的时候，会导致缓存不一致的问题\n\n**解决方法：**JMM 主要围绕如何在并发的过程中处理好**原子性**，**可见性**和**有序性**这三个特性。如果解决了这三个问题，就可以解除缓存不一致的问题了。\n\n## 原子性\n\n原子性操作：执行的操作不可中断，要么都完成，要么都不完成\n\nJMM 实现了基本的原子性，借助 synchronized 和 lock 来保证整块代码的原子性\n\n## 可见性\n\n利用 volatile 来保证可见性。当一个变量被 volatile 修饰时，对它的修改会立即刷新到主存中，当其他线程需要读取该变量时，需要重新去主存中读取新数据\n\n## 有序性\n\nJMM 允许指令的重排序，保证了重排序不会影响到单线程的执行，但是在多线程中很容易出问题\n\nvolatile 可以禁止重排序\n","tags":["面试"],"categories":["面试"]},{"title":"JVM","url":"/2020/03/31/JVM/","content":"\n## JVM 架构和 GC 垃圾回收机制\n\n### JVM 架构图\n\n![20170610165140237.png](http://ww1.sinaimg.cn/large/005HBDIygy1gdd2j7ykilj315g14w79v.jpg)\n\n### JVM 分为三个主要的子系统\n\n#### 1. 类加载器子系统\n\nJava 动态类加载是由类加载器子系统完成的，当它在运行时（非编译时）首次引用一个类时，会加载，连接，初始化这个类。\n\n1. 类的加载\n   查找并加载类的二进制文件（.class 文件）\n   从硬盘中加载到 jvm 里\n2. 类的连接\n   - 验证\n     - 验证加载的.class 文件中的字节码是否有错误\n   - 准备\n     - 为静态变量分配内存空间并赋**默认值**\n       static int a = 10; 此时只是给 a 赋 0 值\n       ![基本数据类型的零值.png](http://ww1.sinaimg.cn/large/005HBDIygy1gdd37nxz7zj30nx05oabw.jpg)\n   - 解析\n     - 符号引用变为直接引用\n       前期阶段：还不知道类的具体内存地址，仅仅通过\"com.pojo.Student\"来代替 Student 类\n       解析阶段：jvm 可以把 Student 类映射为实际的内存地址（在方法区中），之后就会用实际的内存地址代替 Student 类\n3. 类的初始化\n   - 给所有的静态变量赋初值，并且执行静态代码块\n\n#### 2. 运行时数据区\n\n1. 线程共享\n   - 堆\n     - 存放对象的实例和数组\n   - 方法区\n     - 存放类的元数据（描述类的信息），静态变量，静态方法，常量，成员方法\n2. 线程私有\n   - 程序计数器（由于所需要的内存极小，所以是唯一不可能发生内存溢出的区域）\n     在解释执行时告诉线程下一条要执行的指令位置\n     - 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行，选择，循环，异常处理等。\n     - 线程切换时，告诉切换回来的线程上次运行到什么地方了\n   - 虚拟机栈\n     描述方法执行的模型\n     - 方法在执行的同时会在虚拟机栈中创建一个栈帧\n     - 栈帧包括：局部变量表，操作数栈，动态链接，方法出口信息等\n   - 本地方法栈\n     和虚拟机栈一样，只不过操作的方法是本地方法，即调用操作系统的方法\n\n#### 3. 执行引擎\n\n交给运行时数据区的字节码将有执行引擎执行，执行引擎读取字节码并逐行执行。\n\n1. 解释器\n2. 编译器\n3. 垃圾回收器\n","tags":["JVM"],"categories":["JVM"]},{"title":"aliyun笔试","url":"/2020/03/31/aliyun笔试/","content":"\n## 阿里云笔试（2020-3-31）（更新中......）\n\n### 第一题\n\n```java\n/*\n * n个农场，每个农场有 a[i] 只小鸡\n * 每天每个农场均会增长 k 只小鸡\n * 农场的主人在每天结束后都会卖掉一半有最多小鸡的农场的小鸡\n * 问 m 天后所有农场的小鸡总数是多少\n * （双重循环超时）\n */\n\n```\n\n### 第二题\n\n```java\n/*\n * 给 n 个数\n * 所有连续子序列中最大的数出现的期望\n * 保留 6 位小数\n * 例如：3 个数 [2, 5, 6]\n * 所有连续子序列为：[2], [5], [6], [2, 5], [5, 6], [2, 5, 6]\n * 2 最大的出现了 1 次；5 最大的时候出现了 2 次；6 最大的时候出现了 3 次\n * 所以期望为：2 * 1/6 + 5 * 2/6 + 6 * 3/6 = 2.333333\n *\n */\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        Arrays.sort(a);\n        long sum_m = ((1 + n) * n) / 2;\n        double sum_z = 0;\n        for (int i = 0; i < n; i++) {\n            sum_z += a[i] * (i + 1);\n        }\n        double result = sum_z/sum_m;\n        String s = String.format(\"%6f\", result);\n        System.out.println(s);\n\n    }\n}\n\n```\n","tags":["笔试"],"categories":["笔试"]},{"title":"centos7安装jdk简洁版","url":"/2019/08/09/Centos7安装jdk简洁版/","content":"\n## CentOS下用yum命令安装jdk\n\n### 1. 查看是否已安装JDK,卸载\n\n```linux\n[root@192 ~]# yum list installed |grep java\n```\n\n```linux\njava-1.8.0-openjdk.x86_64             1:1.8.0.121-0.b13.el7_3          @updates\njava-1.8.0-openjdk-headless.x86_64    1:1.8.0.121-0.b13.el7_3          @updates\njavapackages-tools.noarch             3.4.1-11.el7                     @base\npython-javapackages.noarch            3.4.1-11.el7                     @base\ntzdata-java.noarch                    2016j-1.el7                      @updates  \n```\n\n**卸载CentOS系统Java环境**\n\n```linux\n[root@192 ~]# yum -y remove java-1.8.0-openjdk*        *表时卸载所有openjdk相关文件输入  \n[root@192 ~]# yum -y remove tzdata-java.noarch         卸载tzdata-java  \n```\n\n### 2. 安装JDK\n\n1. 下载rpm版的jdk1.8\n[link](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n\n2. 将下载好的文件拖到 `/usr` 目录下\n\n3. 执行命令 `rpm -ivh jdk-8u221-linux-x64.rpm`\n\n4. 配置环境变量\n\n    jdk安装目录为 `/usr/java/jdk1.8.0_221-amd64`\n    `vim /etc/profile`\n    在最后面添加下面内容\n\n    ``` bash\n    export JAVA_HOME=/usr/java/jdk1.8.0_221-amd64\n    export CLASSPATH=$JAVA_HOME\\bin:$CLASSPATH\n    export PATH=$JAVA_HOME\\bin:$PATH\n    ```\n\n    保存退出后执行 `source /etc/profile`","tags":["Linux"]},{"title":"Centos7安装jdk环境","url":"/2019/05/11/Centos7安装jdk环境/","content":"\n## CentOS下用yum命令安装jdk\n\n### 1. 查看是否已安装JDK,卸载\n\n```linux\n[root@192 ~]# yum list installed |grep java\n```\n\n```linux\njava-1.8.0-openjdk.x86_64             1:1.8.0.121-0.b13.el7_3          @updates\njava-1.8.0-openjdk-headless.x86_64    1:1.8.0.121-0.b13.el7_3          @updates\njavapackages-tools.noarch             3.4.1-11.el7                     @base\npython-javapackages.noarch            3.4.1-11.el7                     @base\ntzdata-java.noarch                    2016j-1.el7                      @updates  \n```\n\n**卸载CentOS系统Java环境**\n\n```linux\n[root@192 ~]# yum -y remove java-1.8.0-openjdk*        *表时卸载所有openjdk相关文件输入  \n[root@192 ~]# yum -y remove tzdata-java.noarch         卸载tzdata-java  \n```\n\n### 2. 安装JDK\n\n```linux\n[root@192 ~]#  yum -y list java*      # 查看JDK软件包列表\n```\n\n```linux\n[root@192 ~]# yum  install  java-1.8.0-openjdk   java-1.8.0-openjdk-devel      #安装JDK,如果没有java-1.8.0-openjdk-devel就没有javac命令 \n```\n\n```linux\n[root@192 ~]# java -version                           #查看Java版本信息  \nopenjdk version \"1.8.0_121\"  \nOpenJDK Runtime Environment (build 1.8.0_121-b13)  \nOpenJDK 64-Bit Server VM (build 25.121-b13, mixed mode)\n```\n\n### 3. 配置环境变量\n\n通过yum默认安装的路径为   /usr/lib/jvm\n\n```linux\n[root@192 ~]# cd /usr/lib/jvm\n```\n\n```linux\njava\njava-1.8.0\njava-1.8.0-openjdk\njava-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64\njava-openjdk\njre\njre-1.8.0\njre-1.8.0-openjdk\njre-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64\njre-openjdk\n```\n\n```linux\n[root@192 ~]# vi /etc/profile\n```\n\n在文件最后加入如下行\n\n```linux\n#set java environment  \nJAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64\nPATH=$PATH:$JAVA_HOME/bin\nCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport JAVA_HOME  CLASSPATH  PATH\n```\n\n保存关闭,执行如下命令使设置生效\n\n```linux\n[root@192 ~]#  source  /etc/profile\n```\n\n使用以下命令,查看变量\n\n```linux\n[root@192 ~]# echo $JAVA_HOME\n/usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64 \n\n[root@192 ~]# echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/bin:/root/bin\n\n[root@192 ~]# echo $CLASSPATH\n.:/usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.121-0.b13.el7_3.x86_64/lib/dt.jar:/usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/lib/tools.jar\n```\n\n最后：\n**使用  java  -version 和 javac -version 验证.**","tags":["Linux"]},{"title":"MySql-5.7.x安装","url":"/2019/05/11/MySql-5-7-x安装/","content":"\n## MySQL安装教程（压缩包安装）\n\n### 1. 下载\n\n下载压缩包，并解压\n\n### 2. 配系统环境\n\n感觉没啥用，可是找的别人的教程配了\n\n直接把解压路径的bin目录加到系统的Path中去\n\n### 3. 添加my.ini文件\n\n在解压目录下建一个my.ini文件\n\n```ini\n[mysqld]\nport = 3306\nbasedir=C:/software/mysql-5.7.21-winx64 #改成自己的目录\ndatadir=C:/software/mysql-5.7.21-winx64/data  #同上\nmax_connections=200\ncharacter-set-server=utf8\ndefault-storage-engine=INNODB\nsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES\n[mysql]\ndefault-character-set=utf8\n```\n\n### 4. 安装\n\n以管理员身份打开cmd命令窗口，将目录切换到MySQL的安装目录的bin目录下\n\n```mysql\nmysqld -install\n```\n\n### 5. 初始化\n\n```mysql\nmysqld --initialize-insecure --user=mysql\n```\n\n### 6. 启动服务\n\neg：若是卸载mysql，删除服务中的mysql\n\n```cmd\nsc delete 服务名称\n```\n\n启动服务命令\n\n```mysql\nnet start mysql\n```\n\n### 7. 设置密码\n\n启动MySQL之后，root用户的密码为空，设置密码，命令如下：\n\n```mysql\nmysqladmin -u root -p password 新密码\nEnter password: 旧密码\n```\n\n**需要输入旧密码时，由于旧密码为空，所以直接回车即可。**","tags":["MySQL"]},{"title":"dijkstra+优先队列","url":"/2019/05/10/dijkstra-优先队列/","content":"\n## dijkstra+优先队列\n\n```c++\n\n#include<iostream>\n#include<vector>\n#include<queue>\n#define MAX_V 30000\n#define INF 9999999\nusing namespace std;\n\nstruct edge\n{\n    int to;\n    int cost;\n    public:\n        //结构体的构造函数\n        edge(int to1, int cost1){\n            to = to1;\n            cost = cost1;\n        }\n};\n\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V + 10];\nint d[MAX_V + 10];\n\nvoid dijkstra(int s){\n    priority_queue< P, vector<P>, greater<P> > que;\n    fill(d, d + V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()){\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0; i < G[v].size(); i++){\n            edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                que.push(P(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main()\n{\n\n    int m, s, t;\n    int from, to, cost;\n    //V顶点数，m边数，s起点，t终点\n    cin >> V >> m >> s >> t;\n    for(int i = 0; i < m; i++){\n        cin >> from >> to >> cost;\n        //无向边\n        G[from - 1].push_back(edge(to - 1, cost));\n        G[to - 1].push_back(edge(from - 1, cost));\n    }\n\n    //点数-1\n    dijkstra(s - 1);\n    cout << d[t - 1] << endl;\n\n    return 0;\n}\n\n\n```\n","tags":["算法"]},{"title":"n皇后","url":"/2019/05/07/n皇后/","content":"\n## n皇后\n\n```c++\n\n/*\n** 目前最快的N皇后递归解决方法\n** N Queens Problem\n** 试探-回溯算法，递归实现\n*/\n#include <iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\n// sum用来记录皇后放置成功的不同布局数；upperlim用来标记所有列都已经放置好了皇后。\nll sum = 0, upperlim = 1;\n\n// 试探算法从最右边的列开始。\nvoid test(ll row, ll ld, ll rd)\n{\n    if (row != upperlim)\n    {\n        // row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0，\n        // 然后再取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1\n        // 也就是求取当前哪些列可以放置皇后\n        ll pos = upperlim & ~(row | ld | rd);\n        while (pos) // 0 -- 皇后没有地方可放，回溯\n        {\n            // 拷贝pos最右边为1的bit，其余bit置0\n            // 也就是取得可以放皇后的最右边的列\n            ll p = pos & -pos;\n\n            // 将pos最右边为1的bit清零\n            // 也就是为获取下一次的最右可用列使用做准备，\n            // 程序将来会回溯到这个位置继续试探\n            pos -= p;\n\n            // row + p，将当前列置1，表示记录这次皇后放置的列。\n            // (ld + p) << 1，标记当前皇后左边相邻的列不允许下一个皇后放置。\n            // (ld + p) >> 1，标记当前皇后右边相邻的列不允许下一个皇后放置。\n            // 此处的移位操作实际上是记录对角线上的限制，只是因为问题都化归\n            // 到一行网格上来解决，所以表示为列的限制就可以了。显然，随着移位\n            // 在每次选择列之前进行，原来N×N网格中某个已放置的皇后针对其对角线\n            // 上产生的限制都被记录下来了\n            test(row + p, (ld + p) << 1, (rd + p) >> 1);\n        }\n    }\n    else\n    {\n        // row的所有位都为1，即找到了一个成功的布局，回溯\n        sum++;\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    // 因为整型数的限制，最大只能32位，\n    // 如果想处理N大于32的皇后问题，需要\n    // 用bitset数据结构进行存储\n\n    // N个皇后只需N位存储，N列中某列有皇后则对应bit置1。\n    upperlim = (upperlim << n) - 1;\n\n    test(0, 0, 0);\n    printf(\"%lld\\n\", sum);\n    return 0;\n}\n\n```\n","tags":["算法"]},{"title":"贪心_删除k个数","url":"/2019/05/06/贪心-删除k个数/","content":"\n## 贪心 -- N位数删除K个数字，使剩下的数字串最大（小）\n\n```c++\n\nstring deleteKNumbers(string &str, int k){\n    string::iterator start;\n    bool flag;\n    for(int i = k; i > 0; --i){\n        flag = 0;\n        for(start = str.begin(); start < str.end() - 1; ++start){\n            if(*start < *(start + 1)){\n                str.erase(start);\n                flag = 1;\n                break;\n            }\n        }\n        if(!flag){\n            str.erase(str.end() - i, str.end());\n            break;\n        }\n    }\n    return str;\n}\n\n```\n","tags":["算法"]},{"title":"表达式求值","url":"/2019/05/06/表达式求值/","content":"\n## 表达式求值\n\n```c++\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cctype>\n#include<stack>\nusing namespace std;\n\nstack<char> opter; //运算符栈\nstack<double> opval; //操作数栈\n\nint getIndex(char theta){\n    int index = 0;\n    switch (theta)\n    {\n    case '+':\n        index = 0;\n        break;\n    case '-':\n        index = 1;\n        break;\n    case '*':\n        index = 2;\n        break;\n    case '/':\n        index = 3;\n        break;\n    case '(':\n        index = 4;\n        break;\n    case ')':\n        index = 5;\n        break;\n    case '#':\n        index = 6;\n        break;\n    default:\n        break;\n    }\n    return index;\n}\n\nchar getPriority(char theta1, char theta2){\n    const char priority[][7] = {\n        {'>', '>', '<', '<', '<', '>', '>'},\n        {'>', '>', '<', '<', '<', '>', '>'},\n        {'>', '>', '>', '>', '<', '>', '>'},\n        {'>', '>', '>', '>', '<', '>', '>'},\n        {'<', '<', '<', '<', '<', '=', '0'},\n        {'>', '>', '>', '>', '0', '>', '>'},\n        {'<', '<', '<', '<', '<', '0', '='},\n    };\n    int index1 = getIndex(theta1);\n    int index2 = getIndex(theta2);\n    return priority[index1][index2];\n}\n\ndouble calculate(double b, char theta, double a){\n    switch (theta)\n    {\n    case '+':\n        return b + a;\n        break;\n    case '-':\n        return b - a;\n        break;\n    case '*':\n        return b * a;\n        break;\n    case '/':\n        return b / a;\n        break;\n\n    default:\n        break;\n    }\n}\n\ndouble getAnswer(string str){\n    opter.push('#');\n    int counter = 0; //添加变量counter表示有多少个数字相继入栈，实现多位数的四则运算\n    int i = 0;\n    int len = str.length();\n    while(i < len || opter.top() != '#'){\n        char c = str[i];\n        if(isdigit(c)){ //如果在'0'到'9'之间\n            if(counter == 1){ //counter==1表示上一字符也是数字，所以要合并，比如12*12，要算12，而不是单独的1和2\n                double t = opval.top(); //取出最上面的一个操作数\n                opval.pop();            //弹出最上面的一个操作数\n                opval.push(t * 10 + (c - '0')); //整合后入栈\n                counter = 1;\n            }else{\n                opval.push(c - '0');\n                counter++;\n            }\n            i++;\n        }else{\n            counter = 0;\n            switch (getPriority(opter.top(), c))\n            {\n            case '<':\n                opter.push(c);\n                i++;\n                break;\n            case '=':\n                opter.pop();\n                i++;\n                break;\n            case '>':\n                char theta = opter.top();\n                opter.pop();\n                double a = opval.top();\n                opval.pop();\n                double b = opval.top();\n                opval.pop();\n                opval.push(calculate(b, theta, a));\n            }\n        }\n    }\n    return opval.top();\n}\n\nint main()\n{\n    string str;\n    cin >> str;\n    while(!opter.empty()) opter.pop();\n    while(!opter.empty()) opter.pop();\n    double ans = getAnswer(str);\n    printf(\"%.2lf\\n\", ans);\n    return 0;\n}\n```","tags":["算法"]},{"title":"差分数组","url":"/2019/05/06/差分数组/","content":"\n## 差分数组\n\n如果暴力的话肯定会超时\n\n```c++\n\n/*\n    XXX在工作室养了很多花，每天都会浇水，但是由于花的品种不一样，浇水的时间也是不一样的\n    XXX把花摆成了一排 ， 每次他都会给区间[l,r]里面的花浇水\n    现在给XXX每次浇水的区间\n    然后询问你每盆花都被浇了多少次水\n*/\n\n//aininot260\n//修改区间，查询点\n#include<iostream>\n#include<cstring>\nusing namespace std;\nconst int maxn=100005;\nint a[maxn];\nint b[maxn];\n\nint n,q; //q更新查询数\n\nvoid update(int l,int r,int z){\n    b[l] += z;\n    b[r+1] -= z;\n}\n\n//如果最后才查询，可以考虑前缀和\nint sum(int t){\n    int ans = 0;\n    for(int i = 1; i <= t; i++)\n        ans += b[i];\n    return ans;\n}\n\nint main()\n{\n    cin >> n;\n    for(int i = 1; i <= n; i++) // 有初始值\n        cin >> a[i];\n    b[1] = a[1];\n    for(int i = 2; i <= n; i++)\n        b[i] = a[i] - a[i - 1];\n    cin >> q;\n    while(q--)\n    {\n        int type;\n        cin >> type;\n        if(type == 1){ // 1表示更新\n            int l, r, z;\n            cin >> l >> r >> z;\n            update(l, r, z);\n        }\n        if(type == 2){ // 2表示查询\n            int t;\n            cin >> t;\n            cout << sum(t) << endl;\n        }\n    }\n    return 0;\n}\n\n```","tags":["算法"]},{"title":"快速幂","url":"/2019/05/06/快速幂/","content":"\n## 快速幂\n\n利用二进制，降低时间复杂度\n\neg：$3^5$ 需要循环五次\n5 = 101（二进制）\n\n\n当值越大时的时候，差距越大\n\n```c++\n\n/*\n现在有 N 个格子排成一排 ， 假设你有 M 种的颜色\n现在要你给这N个格子都涂上颜色，且每相邻的两个格子的颜色都不能相同，现在要你求有多少种方法涂色方案\n由于答案太大，每次结果对 1000000007 取模\n*/\n\n#define ll long long\n#define mod 1000000007\n\nll fast_Pow(ll a,ll b){\n    ll ans = 1;\n    ll base = a;\n    while(b){\n        if(b & 1)\n            ans = ans * base % mod;\n        base = base * base % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\n```\n","tags":["算法"]},{"title":"git上传命令","url":"/2019/04/16/git上传命令/","content":"\n---\n<!--more-->\n\n```git\ntouch README.md\n```\n\n```git\ngit init\n```\n\n```git\ngit add .\n```\n\n```git\ngit commit -m \"first commit\"\n```\n\n```git\ngit remote add origin https://git.ctguqmx.com/LFool/JavaWeb.git\n```\n\n如果提示：**The requested URL returned error: 403问题**\n则使用下面命令\n\n```git\ngit remote add origin https://LFool@git.ctguqmx.com/LFool/JavaWeb.git\n```\n\n```git\ngit push -u origin master\n```\n\n---\n\n提示**remote origin already exists**先删除远程 Git 仓\n\n```git\ngit remote rm origin\n```\n","tags":["git"],"categories":["git"]},{"title":"答辩-web","url":"/2019/04/16/dabian/","content":"\n---\n\n<!--more-->\n\n## 伪招新网站\n\n### 1.知识准备（JavaWeb）\n\n- 少量前端知识\n  - html\n  - css\n  - js\n- 数据知识\n  - jdbc\n  - 增删改查基本sql命令\n- jsp知识\n  - 九大内置对象\n    - out\n    - request\n    - response\n    - page\n  - servlet\n    - 获取请求信息\n    - 跳转（重定向，请求转发）\n  - 基本模式\n    - MVC\n      - Model层\n      - View层\n      - Controller层\n    - 三层架构\n      - 表示层\n      - 业务逻辑层\n      - 数据访问层\n  \n### 2.进阶学习\n\n#### 登录（MVC）\n\n大致流程：\n\n* JSP -> Servlet -> DB\n\n#### 三层架构\n\n![img](http://ww1.sinaimg.cn/large/005HBDIygy1g24itzf7b1j30va0ffq33.jpg)\n\n#### 完善Dao层（DBUtil）\n\n将数据库的操作提取出来，增加代码的利用率 》》》代码的重构\n\n```java\n//通用增删改\npublic static boolean executeUpdate(String sql, Object[] params) {\n    try {\n        int count = createPreparedStatement(sql, params).executeUpdate();\n        if(count > 0)\n            return true;\n        else\n            return false;\n\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return false;\n\n    } catch (SQLException e) {\n        e.printStackTrace();\n        return false;\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        return false;\n\n    } finally {\n        closeAll(null, pstmt, connection);\n    }\n}\n```\n\n### 结构实现\n\n目录结构\n\n![img](http://ww1.sinaimg.cn/large/005HBDIygy1g24j4qrufmj308e0ccwec.jpg)\n\n![img](http://ww1.sinaimg.cn/large/005HBDIygy1g24j52hszmj306m07y3yh.jpg)\n\n### 小功能\n\n- **表单验证**\n  通过正则表达式（/^(201(7|8))\\d{6}$/）\n\n- **弹窗**\n  通过alter函数\n  ![img](http://ww1.sinaimg.cn/large/005HBDIygy1g24j7r30quj307204hwe9.jpg)\n\n### 总结\n\n1：整体感觉比暑假的答辩好一些，应该是更有用一些\n\n2：这次项目里面的具体实现的功能以后可以用到（最大收获吧）\n\n3：实实在在的感受了一个具体项目从无到有的过程\n","tags":["答辩"],"categories":["答辩"]},{"title":"MySQL基本操作练习题","url":"/2019/03/10/MySQL基本操作练习题/","content":"\n---\n\n<!--more-->\n\n# 数据库操作sql练习\n\n## 一 数据库的创建：\n\n- 创建一个名称为mydb1的数据库\n\n```sql\n    create database mydb1;\n```\n\n- 创建一个使用utf8字符集的mydb2数据库\n\n```sql\n    create database mydb2 character set utf8;\n```\n\n- 创建一个使用utf8字符集，并带比较规则的mydb3数据库\n\n```sql\n    create database mydb3 character set utf8 collate utf8_general_ci;\n```\n\n## 二 数据库的修改：\n\n- 修改mydb2字符集为gbk;\n\n```sql\n    alter database mydb2 character set gbk;\n```\n\n## 三 数据库的删除：\n\n- 删除数据库mydb3。\n\n```sql\n    drop database mydb3;\n```\n\n## 四 数据库查看：\n\n- 查看所有数据库。\n\n```sql\n    show databases;\n```\n\n- 查看数据库mydb1的字符集\n\n```sql\n    show create database mydb1;\n```\n\n---\n\n# 数据库中表操作的sql练习\n\n## 一 创建表\n\n- 创建一张员工表employee\n\n        字段        类型\n        id          整形\n        name        字符型\n        gender      字符型\n        birthday    日期型\n        entry_date  日期型\n        job         字符型\n        salary      小数型\n        resume      文本\n\n- 创建一张员工表employee2\n\n        字段        类型\n        id          整形\n        name        字符型\n        gender      字符型\n        birthday    日期型\n        entry_date  日期型\n        job         字符型\n        salary      小数型\n        resume      文本\n\n要求：把id 设置成主键，并且自动增长。name不允许为空。\n\n```sql\n create table employee (id int primary key auto_increment,\n name varchar(20) not null,\n gender varchar(10),\n birthday date,\n entry_date date,\n job varchar(30),\n salary double,\n resume text\n );\n ```\n\n## 二 删除表\n\n- 删除employee2表\n\n```sql\n    drop table employee;\n```\n\n## 三 数据表的结构的修改：\n\n- 在上面员工表的基本上增加一个image列。\n\n```sql\n    alter table employee add image varchr(20);\n```\n\n- 修改job列，使其长度为60。\n\n```sql\n    alter table employee modify job varchar(60);\n```\n\n- 删除gender列。\n\n```sql\n    alter table employee drop gender;\n```\n\n- 表名改为user。\n\n```sql\n    rename table employee to user;\n```\n\n- 修改表的字符集为utf8\n\n```sql\n    alter table user character set utf8;\n```\n\n- 列名name修改为username\n\n```sql\n    alter table user change name username varchar(20) not null;\n```\n\n## 四 查看表结构\n\n- 查看数据库内的所有表\n\n```sql\n    show tables;\n```\n\n- 查看employee的建表语句\n\n```sql\n    show create table employee;\n```\n\n- 查看employee的表结构\n\n```sql\n   desc employee;\n```\n\n---\n\n# 表记录的操作\n\n## 一 插入语句 ---insert\n\n- 向employee中插入三个员工信息，要求员工姓名分别是zs,ls,wangwu\n\n## 二 更新语句 ---update\n\n- 将所有员工薪水修改为5000元。\n\n```sql\n    update employee set salary=5000 ;\n```\n\n- 将姓名为’zs’的员工薪水修改为3000元。\n\n```sql\n    update employee set salary=3000 where name='zs';\n```\n\n- 将姓名为’ls’的员工薪水修改为4000元,job改为ccc。\n\n```sql\n    update employee set salary=3000,job='ccc' where name='ls';\n```\n\n- 将wangwu的薪水在原有基础上增加1000元。\n\n```sql\n    update employee set salary=salary+1000 where name='wangwu';\n```\n\n## 三 删除语句 ---delete\n\n- 删除表中名称为’zs’的记录。\n\n```sql\n    delete from employee where name='ls';\n```\n\n- 删除表中所有记录。\n\n```sql\n    delete from employee;\n```\n\n## 四 查询语句 ---select\n\n```sql\n    create table exam(\n    id int primary key auto_increment,\n    name varchar(20) not null,\n    chinese double,\n    math double,\n    english double\n    );\n    insert into exam values(null,'关羽',85,76,70);\n    insert into exam values(null,'张飞',70,75,70);\n    insert into exam values(null,'赵云',90,65,95);\n    insert into exam values(null,'刘备',97,50,50);\n    insert into exam values(null,'曹操',90,89,80);\n    insert into exam values(null,'司马懿',90,67,65);\n```\n\n练习：\n\n- 查询表中所有学生的信息\n\n```sql\n    select * from exam;\n```\n\n- 查询表中所有学生的姓名和对应的英语成绩。\n\n```sql\n    select name,english from exam;\n```\n\n- 过滤表中重复数据。\n\n- 在所有学生分数上加10分特长分。\n\n- 统计每个学生的总分。\n\n```sql\n    select *,chinese+math+english from exam;\n```\n\n- 使用别名表示学生分数。\n\n```sql\n    select *,chinese+math+english as 总分 from exam;\n```\n\n### -----使用where子句\n\n7 查询姓名为刘备的学生成绩\n\n```sql\n    select * from exam where name='刘备';\n```\n\n8 查询英语成绩大于90分的同学\n\n```sql\n    select * from exam where english>90;\n```\n\n- 查询总分大于200分的所有同学\n\n```sql\n    select * from exam where chinese+math+english>200;\n```\n\n- 查询英语分数在 80－90之间的同学。\n\n```sql\n    select * from exam where english between 80 and 90;\n    select * from exam where english>=80 and english<=90;\n```\n\n- 查询数学分数为89,75,91的同学。\n\n```sql\n    select * from exam where math=89 or math=75 or math=91;\n    select * from exam where math in(89,75,91);\n```\n\n- 查询所有姓刘的学生成绩。\n\n```sql\n    select * from exam where name like '刘%';\n```\n\n- 查询所有姓刘两个字的学生成绩。\n\n```sql\n    select * from exam where name like '刘_';\n```\n\n- 查询数学分>80并且语文分>80的同学。\n\n```sql\n    select * from exam where math>80 and chinese>80;\n```\n\n- 查询数学分>80 或者 语文分>80的同学。\n\n```sql\n    select * from exam where math>80 or chinese>80;\n```\n\n### ------使用order by  排序\n\n- 对数学成绩排序后输出。\n\n```sql\n    select * from exam order by math;\n```\n\n- 对总分排序按从高到低的顺序输出\n\n```sql\n    select *,chinese+math+english as 总分 from exam order by 总分 desc;\n    select *,chinese+math+english as 总分 from exam order by chinese+math+english desc;\n```\n\n- 对姓刘的学生成绩排序输出\n\n```sql\n    select * from exam where name like '刘%' order by math desc;\n```\n\n### ------使用count（函数）\n\n- 统计一个班级共有多少学生？\n\n```sql\n    select  count(id) from exam;\n```\n\n- 统计数学成绩大于或等于90的学生有多少个？\n\n```sql\n    select  count(math) from exam where math>=90;\n```\n\n- 统计总分大于250的人数有多少？\n\n```sql\n    select count(id) from exam where chinese+math+english>250;\n```\n\n### -------使用sum函数\n\n- 统计一个班级数学总成绩？\n\n```sql\n    select * from exam;\n```\n\n- 统计一个班级语文 英语 数学各科的总成绩\n\n```sql\n    select sum(chinese),sum(math),sum(english) from exam;\n```\n\n- 统计一个班级语文 英语 数学的成绩总和 \n\n```sql\n    select sum(chinese)+sum(math)+sum(english) from exam;\n```\n\n- 统计一个班级语文成绩平均分\n\n```sql\n    select sum(chinese)/count(id) from exam;\n```\n\n### --------使用avg函数\n\n- 求一个班级数学平均分？\n\n```sql\n    select avg(math) from exam;\n```\n\n- 求一个班级总分平均分\n\n```sql\n    select avg(ifnull(chinese,0))+avg(ifnull(math,0))+avg(ifnull(english,0))from exam;\n```\n\n### -------使用max，min函数\n\n- 求班级最高分和最低分（数值范围在统计中特别有用）\n\n```sql\n    select max(ifnull(chinese,0)+ifnull(math,0)+ifnull(english,0)) from exam;\n    select min(ifnull(chinese,0)+ifnull(math,0)+ifnull(english,0)) from exam;\n```\n\n```sql\n    create table orders(\n    id int,\n    product varchar(20),\n    price float\n    );\n\n    insert into orders(id,product,price) values(1,'电视',900);\n    insert into orders(id,product,price) values(2,'洗衣机',100);\n    insert into orders(id,product,price) values(3,'洗衣粉',90);\n    insert into orders(id,product,price) values(4,'桔子',9);\n    insert into orders(id,product,price) values(5,'洗衣粉',90);\n```\n\n- 查询购买了几类商品，并且每类总价大于100的商品\n\n```sql\n    select product,sum(price) from orders group by product having sum(price)>100;\n```\n\n---\n![图片](http://ww1.sinaimg.cn/large/005HBDIygy1g0y1e2kf1mj31bo0qpjtm.jpg)\n","tags":["MYSQL"],"categories":["MYSQL"]},{"title":"VS Code 配置 C++ 环境","url":"/2019/03/05/vs code/","content":"\n---\n\n<!--more-->\n\n# VS Code 安装以及配置 C++ 环境\n\n\n---\n感叹一下，网上的教程几乎都差不多，但是配C++环境的文件真的是都不太一样，自己安了一天才搞好，现在分享一下。\n\n## 安装 VS Code\n\n比较简单，直接去官网上下载\n下载链接：[VS Code](https://code.visualstudio.com/)\n![图片](http://ww1.sinaimg.cn/large/005HBDIygy1g0rwvsvpikj30gk0gjjss.jpg)\n\n<font color=red size=6>切记：在安装完成后的最后一个页面把所有的选项勾选上</font>\n![图片](http://ww1.sinaimg.cn/large/005HBDIygy1g0rxasatd7j30e40ay0td.jpg)\n\n## 配置 C++ 环境\n\n### 安装MinGW w64\n\n如果可以科学上网的话，一定要打开**全局代理**，不然可能访问不了\n下载链接：[Mingw w64离线安装包](https://sourceforge.net/projects/mingw-w64/files/?source=navbar)\n\n根据自己电脑的版本（64位下第二个）\n![图片](http://ww1.sinaimg.cn/large/005HBDIygy1g0rxmt9povj308h074mx7.jpg)\n\n下好后直接解压在一个文件夹里面\n\n### 配置 MinGW w64 的环境\n\n我的电脑 --> 环境变量 --> Path\n\n增加MinGW w64的bin路径\n\n### VS Code安装 Code Runner 插件\n\n![图片](http://ww1.sinaimg.cn/large/005HBDIygy1g0ysnuhjm5j30lb04nmxe.jpg)\n\n设置一下\n![image](http://ww1.sinaimg.cn/large/0071ouepgy1g0ysslncrmj30ep0e7dg9.jpg)\n\n### VS Code安装 C/C++ 插件\n\n注意：下载失败就科学上网，开全局代理模式\n\n![图片](http://ww1.sinaimg.cn/large/005HBDIygy1g0rxuzv2udj30up0dlacd.jpg)\n\n#### 主要是配两个文件\n\nlaunch.json\n\n```json\n{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"(gdb) Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${fileDirname}/${fileBasenameNoExtension}.o\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            //\"externalConsole\": true,\n            \"MIMode\": \"gdb\",\n            \"windows\": {\n                \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\",\n                \"miDebuggerPath\": \"D:\\\\mingw64\\\\bin\\\\gdb.exe\" //改成自己的安装路径\n            },\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"preLaunchTask\": \"Build\"\n        }\n    ]\n}\n```\n\ntasks.json\n\n```json\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [{\n            \"label\": \"Build\",\n            \"command\": \"g++\",\n            \"args\": [\n                \"-g\",\n                \"-Wall\",\n                \"-std=c++11\",\n                \"-lm\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}/${fileBasenameNoExtension}.o\"\n            ],\n            \"windows\": {\n                \"args\": [\n                    \"-g\",\n                    \"-Wall\",\n                    \"-std=c++11\",\n                    \"-lm\",\n                    \"${file}\",\n                    \"-o\",\n                    \"${fileDirname}/${fileBasenameNoExtension}.exe\"\n                ]\n            },\n            \"presentation\": {\n                \"reveal\": \"always\",\n                \"echo\": false,\n                \"focus\": true\n            },\n            \"problemMatcher\": {\n                \"owner\": \"cpp\",\n                \"fileLocation\": \"absolute\",\n                \"pattern\": {\n                    \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(error):\\\\s+(.*)$\",\n                    \"file\": 1,\n                    \"line\": 2,\n                    \"column\": 3,\n                    \"severity\": 4,\n                    \"message\": 5\n                }\n            }\n        },\n        {\n            \"label\": \"Run\",\n            \"type\": \"shell\",\n            \"dependsOn\": \"Build\",\n            \"command\": \"${fileDirname}/${fileBasenameNoExtension}.o\",\n            \"windows\": {\n                \"command\": \"${fileDirname}/${fileBasenameNoExtension}.exe\"\n            },\n            \"args\": [],\n            \"presentation\": {\n                \"reveal\": \"always\",\n                \"focus\": true\n            },\n            \"problemMatcher\": [],\n            \"group\": {\n                \"kind\": \"test\",\n                \"isDefault\": true\n            }\n        }\n    ]\n}\n```\n\n此时就基本完成了，可能说的不是很详细\n附上两个链接，可以去看看 [one](https://zhuanlan.zhihu.com/p/35178331), [two](https://code.visualstudio.com/docs/languages/cpp)","tags":["安装教程"]},{"title":"Internet","url":"/2019/03/02/Internet/","content":"\n---\n\n<!--more-->\n\n# 第1章 概述（待补充）\n\n\n\n## 1.1 计算机网络在信息时代中的作用\n\n因特网 -> 互联网（流行）\n\n互联网的特点\n1. 连通性\n2. 共享\n\n\n## 1.2 互联网概述\n\n#### 几个概念：\n\n  1. 计算机网络（简称网络）：由若干结点和连接这些结点的链路组成\n\n      - 结点可以是计算机（主机），集线器，交换机，路由器\n\n\n  2. 网络：计算机通过链路接到同一个集线器上，形成一个简单的计算机网络\n\n  3. 互连网：网络与网络之间通过路由器互连起来形成互连网\n\n**网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机常称位主机。**\n\n**互连网与互联网的区别：**\n\n- 互连网：通用名词，泛指由多个计算机网络互连而成的计算机网络。通信协议（通信规则）可以是任意的。\n- 互联网：专用名字，指当前全球最大的，开放的，由众多网络互相连接而成的**特定**互连网，采用TCP/IP协议作为通信规则。\n\n#### 发展的三个阶段\n\n  1. 从单个网络 ARPANET 向互连网发展\n  2. 建成了三级结构的互联网（主干网，地区网，校园网（或企业网））\n  3. 形成多层次ISP（Internet Service Provider）结构的互联网\n\n      - 主干ISP\n      - 地区ISP\n      - 本地ISP\n\n\n## 1.3 互联网的组成\n\n边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传输数据，音频，视频）和资源共享。\n\n核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）\n\n#### 边缘部分\n\n计算机之间的通信：主机A的某个进程和主机B上的另一个进程进行通信\n\n1. 客户-服务器方式\n\n    - 客户是服务请求方，服务器是服务提供方\n    - 客户程序：\n\n      - 客户程序必须知道服务器的地址\n      - 不需要特殊的硬件和很复杂的操作系统\n\n    - 服务器程序：\n\n      - 是一种专门用来提供某种服务的程序，**可以同时处理**多个远地或本地客服的请求\n      - 系统启动后自动调用并一直不断地运行着，被动地等待接受来自各地的客户的通行请求\n      - 一般需要有强大的硬件和高级的操作系统\n\n2. 对等连接方式\n\n    - 每台主机既是客户同时也是服务器\n\n#### 核心部分\n\n1. 电话交换\n    - 建立连接 -> 通话（一直占用通信资源） -> 释放连接\n    - 整个报文的比特流连续地从源点直达终点，好像在一个管道中传递\n\n2. 报文交换\n    - 整个报文先传到相邻结点，全部存储下来后查找转发表，转发到下一个结点\n\n3. 分组交换\n    - 单个分组传递到相邻的结点，储存下来后查找转发表，转发到下一个结点\n    - 优点：\n\n      - 高效\n      - 灵活\n      - 迅速\n      - 可靠\n\n**连续传递大量的数据，且其传递时间远大于连接建立时间，则电路交换的传输速率较快**\n\n**分组交换比报文交换的时延小，同时也具有更好的灵活性**\n\n\n\n## 1.4 计算机网络在我国的发展\n\n#### 略\n\n## 1.5 计算机网络的类别\n\n1. 按照网络的作用范围进行分类\n\n    - 广域网\n    - 城域网\n    - 局域网\n    - 个人区域网\n\n\n2. 按照网络的使用者进行分类\n\n    - 公用网：个人用户\n    - 专用网：特殊部门专门的网络（如：军队，铁路，银行，电力）\n\n\n3. 用来把用户接入到互联网的网络\n\n    - 接入网（本地接入网或居民接入网）：类似于宽带\n\n## 1.6 计算机网络的性能\n\n关系换算：表示数据量的话通常以1024为基准，表示大小（比如速率，带宽）就以1000为基准\n\n1. 速率\n\n    - 数据传输速度，也称为数据率（单位：bit/s）\n    - 1字节 = 8bit\n\n\n2. 带宽\n\n    - 某个信号具有的频率宽度（单位：Hz）\n    - 网络中某通道传送数据的能力（单位：bit/s）\n    - 带宽越宽，传输的最高数据率也越高\n\n\n3. 吞吐量\n\n    - 单位时间内通过某个网络的**实际**数据量\n\n4. 时延\n\n    - 数据从网络的一端到另一端所需的时间\n    - 几个子概念\n\n      - 发送时延（传输时延）\n\n          - 主机或路由器发送数据帧所需要的时间（从第一个比特算起，到最后一个比特发送完毕）\n          - 发送时延 = $\\frac{数据帧长度(bit)}{发送速率(bit/s)}$\n\n      - 传播时延\n\n          - 电磁波在信道中传播一定距离需要花费的时间\n          - 传播时延 = $\\frac{信道长度(m)}{电磁波在信道中传播上传播速率(m/s)}$\n          - 电磁波在自由空间的传播速率是光速，在铜线电缆中的传播速率约为2.3 * 10^5km/s，在光纤中的传播速率约为2.0 * 10^5km/s，1000km长的光纤线路产生的传播延时约为5ms\n\n      - 处理时延\n\n        - 主机或路由器在收到分组时要花费一定的时间进行处理\n\n      - 排队时延\n\n        - 分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理\n\n        **总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延**\n\n      - 时延带宽积\n\n        - 时延带宽积 = 传播时延 x 带宽\n        - 链路的时延带宽积又称为以比特为单位的链路长度\n\n      - 往返时间PTT\n\n        - 发送时间 = $\\frac{数据长度}{发送速率}$\n        - 有效数据率 = $\\frac{数据长度}{发送时间 + PTT}$\n\n      - 利用率\n\n        - D<sub>0</sub> 表示网络空闲的延时\n        - D 表示网络当前的时延\n        - U 表示利用率\n        - D = $\\frac{D_0}{1-U}$\n\n## 1.7 计算机网络体系结构\n\n#### 暂时略，待更新\n","tags":["Internet"],"categories":["Internet"]},{"title":"CSS&&JS","url":"/2019/03/02/02-CSS&JS/","content":"\n---\n\n<!--more-->\n\n# CSS&&JS\n\n\n\n#### 使用CSS完成网站首页的优化\n\n#### 使用CSS完成网站注册页面的优化\n\n#### 使用JS完成简单的数据校验\n\n#### 使用JS完成图片的轮播效果\n\n<br/>\n\n\n### 使用CSS完成网站首页的优化\n\n#### 需求分析:\n\n​\t由于使用表格布局存在缺陷,那么我们要来考虑使用DIV+CSS来对页面进行优化\n\n表格布局的缺陷:\n\n\t1. 嵌套层级太多, 一旦出现嵌套顺序错乱, 整个页面达不到预期效果\n\t2. 采用表格布局,页面不够灵活, 动其中某一块,整个表格布局的结构全都要变\n\n#### 技术分析\n\nHTML的块标签:\n\n\t​1. div标签: 默认占一行,自动换行\n\t2. span标签:  内容显示在同一行\n\nCSS概述:\n\n\tCascading Style Sheets : 层叠样式表\n\n主要用作用:\n\n\t用来美化我们的HTML页面的\n\n\t​HTML 决定网页的骨架\t,CSS  化妆\n\n\t​将页面的HTML和美化进行分离\n\nCSS的简单语法:\n\n\t在一个style标签中,去编写CSS内容,最好将style标签写在这个head标签中\n\n```html\n<style>\n  选择器{\n    属性名称:属性的值;\n    属性名称2: 属性的值2;\n  }\n</style>\n```\n\nCSS选择器: 帮助我们找到我们要修饰的标签或者元素\n\n\n\n元素选择:\n\n```html\n元素的名称{\n  属性名称:属性的值;\n  属性名称:属性的值;\n}\n```\n\nID选择器:\n\n```html\n以#号开头  ID在整个页面中必须是唯一的s\n#ID的名称{\n  属性名称:属性的值;\n  属性名称:属性的值;\n}\n```\n\n类选择器:\n\n```html\n以 . 开头\n.类的名称{\n   属性名称:属性的值;\n  \t属性名称:属性的值;\n}\n```\n\n\n\nCSS的引入方式:\n\n​\t外部样式: 通过link标签引入一个外部的css文件\n\n​\t内部样式: 直接在style标签内编写CSS代码\n\n​\t行内样式: 直接在标签中添加一个style属性, 编写CSS样式\n\n\n\nCSS浮动 : 浮动的元素会脱离正常的文档流,在正常的文档流中不占空间\n\n\t\t\t\tfloat属性:\n\t\t\t\t\tleft\n\t\t\t\t\tright\n\n\t\t\t\tclear属性: 清除浮动\n\t\t\t\t\tboth : 两边都不允许浮动\n\t\t\t\t\tleft: 左边不允许浮动\n\t\t\t\t\tright : 右边不允许浮动\n\t\t\t\t流式布局\n\n\n#### 步骤分析:\n\n1. 创一个最外层div\n2. 第一部份: LOGO部分: 嵌套三个div\n3. 第二部分: 导航栏部分 : 放置5个超链接\n4. 第三部分: 轮播图\n5. 第四部分:\n6. 第五部分: 直接放一张图片\n7. 第六部分: 抄第四部分的\n8. 第七部分: 放置一张图片\n9. 第八部分: 放一堆超链接\n\n\n#### 代码实现:\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title></title>\n\t\t<style>\n\n\t\t\t.logo{\n\t\t\t\tfloat: left;\n\t\t\t\twidth: 33%;\n\t\t\t\t/*border-width: 1px;\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: red;*/\n\t\t\t\theight: 60px;\n\t\t\t\tline-height: 60px;\n\t\t/*\t\tborder: 1px solid red;*/\n\t\t\t}\n\n\n\t\t\t.amenu{\n\t\t\t\tcolor: white;\n\t\t\t\ttext-decoration: none;\n\t\t\t\theight: 50px;\n\t\t\t\tline-height: 50px;\n\t\t\t}\n\n\t\t\t.product{\n\t\t\t\tfloat: left; text-align: center; width: 16%; height: 240px;\n\t\t\t}\n\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<!--\n\t\t\t1. 创一个最外层div\n\t\t\t2. 第一部份: LOGO部分: 嵌套三个div\n\t\t\t3. 第二部分: 导航栏部分 : 放置5个超链接\n\t\t\t4. 第三部分: 轮播图\n\t\t\t5. 第四部分:\n\t\t\t6. 第五部分: 直接放一张图片\n\t\t\t7. 第六部分: 抄第四部分的\n\t\t\t8. 第七部分: 放置一张图片\n\t\t\t9. 第八部分: 放一堆超链接\n\t\t-->\n\t\t<div>\n\t\t\t<!--2. 第一部份: LOGO部分: 嵌套三个div-->\n\t\t\t<div>\n\t\t\t\t<div class=\"logo\">\n\t\t\t\t\t<img src=\"../img/logo2.png\"/>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"logo\">\n\t\t\t\t\t<img src=\"../img/header.png\"/>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"logo\">\n\t\t\t\t\t<a href=\"#\">登录</a>\n\t\t\t\t\t<a href=\"#\">注册</a>\n\t\t\t\t\t<a href=\"#\">购物车</a>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\n\t\t\t<!--清除浮动-->\n\t\t\t<div style=\"clear: both;\"></div>\n\n\n\t\t\t<!--3. 第二部分: 导航栏部分 : 放置5个超链接-->\n\t\t\t<div style=\"background-color: black; height: 50px;\">\n\t\t\t\t<a href=\"#\" class=\"amenu\">首页</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">手机数码</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">电脑办公</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">鞋靴箱包</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">香烟酒水</a>\n\t\t\t</div>\n\n\n\t\t\t<!--4. 第三部分: 轮播图-->\n\t\t\t<div>\n\t\t\t\t<img src=\"../img/1.jpg\" width=\"100%\"/>\n\t\t\t</div>\n\t\t\t<!--5. 第四部分:-->\n\t\t\t<div>\n\t\t\t\t<div><h2>最新商品<img src=\"../img/title2.jpg\"/></h2></div>\n\n\t\t\t\t<!--左侧广告图-->\n\t\t\t\t<div style=\"width: 15%; height: 480px;  float: left;\">\n\t\t\t\t\t<img src=\"../products/hao/big01.jpg\" width=\"100%\" height=\"100%\"/>\n\t\t\t\t</div>\n\t\t\t\t<!--\n                \t右侧商品\n                -->\n                <div style=\"width: 84%; height: 480px;float: left;\">\n                \t<div style=\"height: 240px; width: 50%; float: left;\">\n                \t\t<img src=\"../products/hao/middle01.jpg\" height=\"100%\" width=\"100%\" />\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\n                </div>\n\t\t\t</div>\n\n\t\t\t<!--6. 第五部分: 直接放一张图片-->\n\t\t\t<div>\n\t\t\t\t<img src=\"../products/hao/ad.jpg\" width=\"100%\"/>\n\t\t\t</div>\n\t\t\t<!--7. 第六部分: 抄第四部分的-->\n\t\t\t<div>\n\t\t\t\t<div><h2>最新商品<img src=\"../img/title2.jpg\"/></h2></div>\n\n\t\t\t\t<!--左侧广告图-->\n\t\t\t\t<div style=\"width: 15%; height: 480px;  float: left;\">\n\t\t\t\t\t<img src=\"../products/hao/big01.jpg\" width=\"100%\" height=\"100%\"/>\n\t\t\t\t</div>\n\t\t\t\t<!--\n                \t右侧商品\n                -->\n                <div style=\"width: 84%; height: 480px;float: left;\">\n                \t<div style=\"height: 240px; width: 50%; float: left;\">\n                \t\t<img src=\"../products/hao/middle01.jpg\" height=\"100%\" width=\"100%\" />\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\t\t\t\t\t<div class=\"product\">\n                \t\t<img src=\"../products/hao/small08.jpg\" />\n                \t\t<p>高压锅</p>\n                \t\t<p style=\"color: red;\">$998</p>\n                \t</div>\n\n                </div>\n\t\t\t</div>\n\n\t\t\t<!--8. 第七部分: 放置一张图片-->\n\t\t\t<div>\n\t\t\t\t<img src=\"../img/footer.jpg\" width=\"100%\"/>\n\t\t\t</div>\n\t\t\t<!--9. 第八部分: 放一堆超链接-->\n\t\t\t<div style=\"text-align: center;\">\n\n\t\t\t\t\t<a href=\"#\">关于我们</a>\n\t\t\t\t\t<a href=\"#\">联系我们</a>\n\t\t\t\t\t<a href=\"#\">招贤纳士</a>\n\t\t\t\t\t<a href=\"#\">法律声明</a>\n\t\t\t\t\t<a href=\"#\">友情链接</a>\n\t\t\t\t\t<a href=\"#\">支付方式</a>\n\t\t\t\t\t<a href=\"#\">配送方式</a>\n\t\t\t\t\t<a href=\"#\">服务声明</a>\n\t\t\t\t\t<a href=\"#\">广告声明</a>\n\n\t\t\t\t\t<br />\n\n\t\t\t\t\tCopyright © 2005-2016 传智商城 版权所有\n\t\t\t</div>\n\t\t</div>\n\t</body>\n</html>\n```\n\n\n\n#### 扩展:\n\n- CSS的优先级\n\n  按照选择器搜索精确度来编写:\t\t \t行内样式 > ID选择器 > 类选择器  > 元素选择器\n\n  就近原则: 哪个离得近,就选用哪个的样式\n\n\n  CSS: 层叠样式表\n\n  主要作用:\n\n  \t1. 美化页面\n  \t2. 将页面美化和HTML代码进行分离,提高代码的服用型\n\n  - 选择器:\n\n    - 元素选择器: 标签的名称{}\n    - 类选择器:   以. 开头  .类的名称\n    - ID选择器:  以#开头 ,   #ID的名称  (ID必须是页面上面唯一)\n\n  - CSS浮动:\n\n    - float : left, right  不再占有正常文档流中的空间 , 流式布局\n\n    - clear : both  left right\n\n      ​\n\n- CSS中的其它选择器\n\n  - 选择器分组: 选择器1,选择器2{ 属性的名称:属性的值}\n\n  - 属性选择器:\n\n    ```html\n    a[title]\n    a[titile='aaa']\n    a[href][title]\n    a[href][title='aaa']\n    ```\n\n  - 后代选择器: 爷爷选择器  孙子选择器   找出所有的后代\n\n  - 子元素选择器:  父选择器  > 儿子选择器\n\n  - 伪类选择器: 通常都是用在A标签上\n\n  ​\n\n  ​\n\n### 使用DIV+CSS完成注册页面的优化\n\n#### 需求分析\n\n由于我们的注册页面也是用table布局的,存在与首页同样的问题,所以我们需要使用div+css对我们的注册页面进行美化\n\n总共是5部分内容\n\n#### 技术分析\n\nCSS的盒子模型: 万物皆盒子\n\n内边距:\n\npadding-top:\n\npadding-right:\n\npadding-bottom:\n\npadding-left:\n\n```html\npadding:10px;  上下左右都是10px\npadding:10px 20px;  上下是10px 左右是20px\npadding: 10px 20px 30px;  上 10px 右20px  下30px  左20px\npadding: 10px 20px 30px 40px;  上右下左, 顺时针的方向\n```\n\n\n\n外边距:\n\nmargin-top:\n\nmargin-right:\n\nmargin-bottom:\n\nmargin-left:\n\n\n\nCSS绝对定位:\n\n​\tposition: absolute\n\n​\ttop: 控制距离顶部的位置\n\n​\tleft: 控制距离左边的位置\n\n#### 步骤分析:\n\n1. 总共是5部分\n2. 第一部分是LOGO部分\n3. 第二部分是导航菜单\n4. 第三部分是注册部分\n5. 第四部分是FOOTER图片\n6. 第五部分是一堆超链接\n\n#### 代码实现:\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title></title>\n\t\t <link rel=\"stylesheet\" type=\"text/css\" href=\"../css/main.css\"/>\n\t</head>\n\t<body>\n\t\t<!--\n\t\t\t1. 总共是5部分\n\t\t\t2. 第一部分是LOGO部分\n\t\t\t3. 第二部分是导航菜单\n\t\t\t4. 第三部分是注册部分\n\t\t\t5. 第四部分是FOOTER图片\n\t\t\t6. 第五部分是一堆超链接\n\t\t-->\n\t\t<div>\n\n\t\t\t<!--2. 第一部分是LOGO部分-->\n\t\t\t<div>\n\t\t\t\t<div class=\"logo\">\n\t\t\t\t\t<img src=\"../img/logo2.png\" />\n\t\t\t\t</div>\n\t\t\t\t<div class=\"logo\">\n\t\t\t\t\t<img src=\"../img/header.png\" />\n\t\t\t\t</div>\n\t\t\t\t<div class=\"logo\">\n\t\t\t\t\t<a href=\"#\">登录</a>\n\t\t\t\t\t<a href=\"#\">注册</a>\n\t\t\t\t\t<a href=\"#\">购物车</a>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<!--清除浮动-->\n\t\t\t<div style=\"clear: both;\"></div>\n\t\t\t<!--3. 第二部分是导航菜单-->\n\t\t\t<div style=\"background-color: black; height: 50px;\">\n\t\t\t\t<a href=\"#\" class=\"amenu\">首页</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">手机数码</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">电脑办公</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">鞋靴箱包</a>\n\t\t\t\t<a href=\"#\" class=\"amenu\">香烟酒水</a>\n\t\t\t</div>\n\t\t\t<!--4. 第三部分是注册部分-->\n\t\t\t<div style=\"background: url(../image/regist_bg.jpg);height: 500px;\">\n\n\t\t\t\t<div style=\"position:absolute;top:200px;left:350px;border: 5px solid darkgray;width: 50%;height: 50%;background-color: white;\">\n\t\t\t\t\t<table width=\"60%\" align=\"center\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td colspan=\"2\"><font color=\"blue\" size=\"6\">会员注册</font>USER REGISTER</td>\n\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>用户名:</td>\n\t\t\t\t\t\t\t<td><input type=\"text\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>密码:</td>\n\t\t\t\t\t\t\t<td><input type=\"password\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>确认密码:</td>\n\t\t\t\t\t\t\t<td><input type=\"password\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>email:</td>\n\t\t\t\t\t\t\t<td><input type=\"email\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>姓名:</td>\n\t\t\t\t\t\t\t<td><input type=\"text\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>性别:</td>\n\t\t\t\t\t\t\t<td><input type=\"radio\" name=\"sex\"/> 男\n\t\t\t\t\t\t\t<input type=\"radio\" name=\"sex\"/> 女\n\t\t\t\t\t\t\t<input type=\"radio\" name=\"sex\"/> 妖\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>出生日期:</td>\n\t\t\t\t\t\t\t<td><input type=\"date\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td>验证码:</td>\n\t\t\t\t\t\t\t<td><input type=\"text\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t<td><input type=\"submit\" value=\"注册\"/></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</div>\n\n\t\t\t</div>\n\n\t\t\t<!--5. 第四部分是FOOTER图片-->\n\t\t\t<div>\n\t\t\t\t<img src=\"../img/footer.jpg\" width=\"100%\"/>\n\t\t\t</div>\n\t\t\t<!--9. 第四部分: 放一堆超链接-->\n\t\t\t<div style=\"text-align: center;\">\n\n\t\t\t\t\t<a href=\"#\">关于我们</a>\n\t\t\t\t\t<a href=\"#\">联系我们</a>\n\t\t\t\t\t<a href=\"#\">招贤纳士</a>\n\t\t\t\t\t<a href=\"#\">法律声明</a>\n\t\t\t\t\t<a href=\"#\">友情链接</a>\n\t\t\t\t\t<a href=\"#\">支付方式</a>\n\t\t\t\t\t<a href=\"#\">配送方式</a>\n\t\t\t\t\t<a href=\"#\">服务声明</a>\n\t\t\t\t\t<a href=\"#\">广告声明</a>\n\n\t\t\t\t\t<br />\n\n\t\t\t\t\tCopyright © 2005-2016 传智商城 版权所有\n\t\t\t</div>\n\n\t\t</div>\n\t</body>\n</html>\n\n```\n\n\n### 使用JS完成简单的数据校验\n\n#### 需求分析\n\n使用JS完成对注册页面的简单数据校验,不允许出现用户名或密码为空的情况\n\n\n\n#### 技术分析\n\n##### JavaScript概述\n\n什么是javascript:\n\n\tJavaScript一种直译式脚本语言，\n\n什么是脚本语言?\n\n\tjava源代码 ----> 编译成.class文件 -----> java虚拟机中才能执行\n\n\t脚本语言:   源码  -------- > 解释执行\n\n\t​js由我们的浏览器来解释执行\n\n\tHTML: 决定了页面的框架\n\n\tCSS: 用来美化我们的页面\n\n\tJS:\t提供用户的交互的\n\n##### JS的组成:\n\nECMAScript : 核心部分 ,定义js的语法规范\n\nDOM: document Object Model 文档对象模型 , 主要是用来管理页面的\n\nBOM : Browser Object Model  浏览器对象模型, 前进,后退,页面刷新, 地址栏, 历史记录, 屏幕宽高\n\n##### JS的语法:\n\n变量弱类型: var i = true\n\n区分大小写\n\n语句结束之后的分号 ,可以有,也可以没有\n\n写在script标签\n\n\n##### JS的数据类型:\n\n- 基本类型\n  - string\n  - number\n  - boolean\n  - undefine\n  - null\n- 引用类型\n  - 对象, 内置对象\n- 类型转换\n  - js内部自动转换\n\n##### JS的运算符和语句:\n\n- 运算符和java 一样\n  - \"===\" 全等号: 值和类型都必须相等\n  - == 值相等就可以了\n- 语句和java 一样\n\n\n##### JS的输出\n\n- alert()  直接弹框\n- document.write()  向页面输出\n- console.log() 向控制台输出\n- innerHTML:  向页面输出\n\n\n\n- 获取页面元素: document.getElementById(\"id的名称\");\n\n\n\nJS声明变量:\n\n​\tvar 变量的名称 = 变量的值\n\nJS声明函数:\n\n​\tvar 函数的名称 = function(){\n\n​\t}\n\n​\n\n​\tfunction 函数的名称(){\n\n​\t}\n\n#### JS的开发步骤\n\n```html\n1. 确定事件\n2. 通常事件都会出发一个函数\n3. 函数里面通常都会去操作页面元素,做一些交互动作\n\n```\n\n#### 步骤分析:\n\n\n\n#### 代码实现\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title></title>\n\t\t<script>\n\t\t\t/*\n\t\t\t\t1. 确认事件: 表单提交事件 onsubmit事件\n\t\t\t\t2. 事件所要触发的函数: checkForm\n\t\t\t\t3. 函数中要干点事情\n\t\t\t\t\t1. 校验用户名, 用户不能为空, 长度不能小于6位\n\t\t\t\t\t\t1.获取到用户输入的值\n\t\t\t*/\n\t\t\tfunction checkForm(){\n\t\t\t\t//获取用户名输入项\n\t\t\t\tvar inputObj = document.getElementById(\"username\");\n\t\t\t\t//获取输入项的值\n\t\t\t\tvar uValue = inputObj.value;\n//\t\t\t\talert(uValue);\n\t\t\t\t//用户名长度不能6位 \"\"\n\t\t\t\tif(uValue.length < 6 ){\n\t\t\t\t\talert(\"对不起,您的长度太短!\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t//密码长度大于6 和确认必须一致\n\n\t\t\t\t//获取密码框输入的值\n\t\t\t\tvar input_password = document.getElementById(\"password\");\n\t\t\t\tvar uPass = input_password.value;\n\n\t\t\t\tif(uPass.length < 6){\n\t\t\t\t\talert(\"对不起,您还是太短啦!\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//获取确认密码框的值\n\t\t\t\tvar input_repassword = document.getElementById(\"repassword\");\n\t\t\t\tvar uRePass = input_repassword.value;\n\t\t\t\tif(uPass != uRePass){\n\t\t\t\t\talert(\"对不起,两次密码不一致!\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//校验手机号\n\t\t\t\tvar input_mobile = document.getElementById(\"mobile\");\n\t\t\t\tvar uMobile = input_mobile.value;\n\t\t\t\t//\n\t\t\t\tif(!/^[1][3578][0-9]{9}$/.test(uMobile)){\n\n\t\t\t\t\talert(\"对不起,您的手机号无法识别!\");\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//校验邮箱: /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-])+/\n\t\t\t\tvar inputEmail = document.getElementById(\"email\");\n\t\t\t\tvar uEmail = inputEmail.value;\n\n\t\t\t\tif(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-])+/.test(uEmail)){\n\t\t\t\t\talert(\"对不起,邮箱不合法\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t</script>\n\t</head>\n\t<body>\n\t\t<form action=\"JS开发步骤.html\" onsubmit=\"return checkForm()\">\n\t\t\t<div>用户名:<input id=\"username\" type=\"text\"  /></div>\n\t\t\t<div>密码:<input id=\"password\" type=\"password\"  /></div>\n\t\t\t<div>确认密码:<input id=\"repassword\" type=\"password\"  /></div>\n\t\t\t<div>手机号码:<input id=\"mobile\"  type=\"number\"  /></div>\n\t\t\t<div>邮箱:<input id=\"email\" type=\"text\"  /></div>\n\t\t\t<div><input type=\"submit\" value=\"注册\"  /></div>\n\t\t</form>\n\t</body>\n</html>\n```\n\n\n\njavascript :  它是一门脚本语言 , 直接解释执行的语言\n\njavascript:\n\n\t​\tECMAScript : 定义的语法\n\n\t​\tDOM: document Object Model\n\n\t​\tBOM: 浏览器对象模型\n\n\n\n\t会定义变量: var  变量的名称 = 变量的值\n\n\n\n\t会定义函数:\n\n\t​\tfunction 函数的名称(参数的名称){\n\n\t​\t}\n\n\n\n\n\n### 使用JS完成图片的轮播效果\n\n#### 需求分析\n\n在网站首页,通常需要有一块区域,用来显示广告,但是这块区域如果仅仅显示一张图片肯定是不够的, 故我们需要采用动态循环播放我们所有的广告\n\n#### 技术分析:\n\n\n\n### 步骤分析:\n\n#### 代码实现:\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title></title>\n\t\t<script>\n\t\t\t/* 当页面加载完成的时候, 动态切换图片\n\t\t\t\t 1.确定事件:\n\t\t\t\t 2.事件所要触发的函数\n\t\t\t */\n\t\t\tvar index = 1;\n\t\t\t//切换图片的函数\n\t\t\tfunction changeAd(){\n\t\t\t\t//获取要操作的img\n\t\t\t\tvar img = document.getElementById(\"imgAd\");\n\t\t\t\timg.src = \"../img/\"+(index%3+1)+\".jpg\";  //0,1,2    //1,2,3\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tfunction init(){\n\t\t\t\t//启动定时器\n\t\t\t\tsetInterval(\"changeAd()\",3000);\n\t\t\t}\n\t\t</script>\n\t</head>\n\t<body onload=\"init()\">\n\t\t<img src=\"../img/1.jpg\" id=\"imgAd\"/>\n\t</body>\n</html>\n```\n","tags":["CSS","JS"],"categories":["CSS","JS"]},{"title":"数据库---绪论","url":"/2019/02/28/SQL0/","content":"\n---\n\n<!--more-->\n\n# 绪论\n\n## 一. 数据库系统概论\n\n### 数据库的四个概念\n\n**1. 数据**\n\t&emsp;描述事物的符号记录\n\n\n**2. 数据库**\n&emsp;长期存储在计算机内，有组织的，可共享的大量数据的集合\n\n**3. 数据库管理系统(DBMS)**\n&emsp;位于操作系统之上\n&emsp;功能：\n     &emsp;&emsp;1. 数据定义功能\n     &emsp;&emsp;2. 数据组织，存储和管理\n     &emsp;&emsp;3. 数据操纵功能\n     &emsp;&emsp;4. 数据库的事务管理和运行功能\n     &emsp;&emsp;&emsp;&emsp;a. 安全性（第四章）\n     &emsp;&emsp;&emsp;&emsp;b. 完整性（第五章）\n     &emsp;&emsp;&emsp;&emsp;c. 多用户对数据的并发使用（第十一章）\n     &emsp;&emsp;&emsp;&emsp;d. 发生故障后的系统恢复（第十章）\n     &emsp;&emsp;5. 数据库的建立和维护功能\n\n**4. 数据库系统**\n\n&emsp;&emsp;由数据库，数据库管理系统，应用程序和数据库管理员组成的存储，管理，处理和维护数据的系统\n\n### 数据库的产生和发展\n\n**1. 人工管理阶段**\n\n&emsp;特点：\n  1. 数据不保存\n  2. 应用程序管理数据\n  3. 数据不共享\n  4. 数据不具有独立性\n\n**2. 文件系统管理阶段**\n\n&emsp;特点：\n  1. 数据可以长期保存\n  2. 由文件管理系统管理数据\n\n&emsp;缺点：\n  1. 数据共享性差，冗余度大\n  2. 数据独立性差\n\n**3. 数据库系统阶段**\n\n&emsp;&emsp;从文件系统到数据库系统标志着数据管理技术的飞跃\n\n### 数据库的特点\n\n1. 数据结构化\n2. 数据的共享性高，冗余度底且易扩充\n3. 数据独立性高\n4. 数据由数据库管理系统统一管理和控制\n\n\n\n## 二. 数据模型\n\n### 两类数据模型\n\n1. 概念模型\n2. 逻辑模型和物理模型(结构模型)\n    - 非关系模型\n    - 关系模型\n\n\n\n\n### 模型概念\n\n**1. 基本概念**\n\n&emsp;&emsp;实体：客观存在并可以相互区别的事物\n\n&emsp;&emsp;属性：实体所具有的某一特征\n\n&emsp;&emsp;码：唯一标识实体的属性集\n\n&emsp;&emsp;实体型：用实体名及其属性名集合来抽象和刻画同类实体\n\n&emsp;&emsp;实体集：同一类型实体的集合\n\n&emsp;&emsp;联系：实体之间的联系\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;一对一\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;一对多\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;多对多\n\n**2. 概念模型的表示方法：** 实体-联系方法\n\n\n---\n**问题一：**\n**&emsp;与文件结构相比，数据库结构有什么不同？**\n\n 1. 数据的结构化：文件由记录组成，但各个文件间缺乏联系，数据库中的数据在磁盘中虽然以文件的形式组织，但这些文件间有广泛的联系。\n 2. 数据的独立性：文件只有设备独立性，而数据库还具有逻辑独立性和物理独立性。\n 3. 访问数据的单位：访问文件中的数据，以记录为单位，访问数据库中的数据，以字段为单位\n","tags":["MYSQL"],"categories":["MYSQL"]},{"title":"数据库---关系数据库","url":"/2019/02/28/SQL1/","content":"\n---\n\n<!--more-->\n\n# 第二章：关系数据结构及形式化定义\n\n---\n\n前言：\n&emsp;系统，严格地提出关系模型的是美国IBM公司的 **E.F.Codd**\n\n---\n\n## 1. 关系模型的大体情况\n\n&emsp;a. 关系模型建立在**集合**的基础之上，因此数据结构的定义由集合论的方法给出\n\n&emsp;b. 关系模型只包含**单一数据结构** ---- 关系\n\n&emsp;c. 关系模型中数据的逻辑结构是一张扁平的**二维表**\n\n&emsp;d. 现实中的实体与实体之间的联系都可以用关系表示\n\n&emsp;e. 关系可以简称为表\n\n<br/>\n\n## 2. 域和笛卡尔积\n\n&emsp;a. **域（D）**：一组具有相同数据类型的值的集合\n\n&emsp;b. **笛卡尔积：** D1×D2×···×Dn = {（d1, d2 ,···, dn）|  di∈Di, i = 1, 2, 3,···, n}\n\n&emsp;&emsp;笛卡尔积可以对应一张二维表，表中的每一行对应一个元组，每一列来自一个域；\n\n&emsp;c. **元祖：** 即（d1, d2 ,···, dn），称为一个n元组  --------  二维表中的每一行都是一个元祖\n\n&emsp;d. **分量：** 即di；一个元祖中的一个值\n\n&emsp;e. **基数：** 元祖的个数\n\n<br/>\n\n## 3. 用笛卡尔积定义关系的数据结构\n\n&emsp;a. **关系**就是笛卡尔积的有限子集，即为：R（D1, D2,···, Dn），其中R为关系的名字\n\n&emsp;b. **目/度：** n就称为关系的目或度（属性的个数），最常见的两种关系：\n\n&emsp;&emsp;&emsp;&emsp;&emsp;单元关系/一元关系\n\n&emsp;&emsp;&emsp;&emsp;&emsp;二元关系\n\n&emsp;c. **关系二维表** 中的相关定义\n\n&emsp;&emsp;&emsp;&emsp;i. **关系**是笛卡尔积的有限子集，所以关系也是一张二维表\n\n&emsp;&emsp;&emsp;&emsp;ii. **属性：** 即表中每一列的名字，由于每一列都对应一个域，而域是可以相同的，为了加以区分，因此属性名相互之间必须不同，因此n目关系必有n中属性\n\n&emsp;&emsp;&emsp;&emsp;iii. **码（Key）** 的概念\n\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;i. **候选码：** 若关系中的某一属性组的值能唯一的标识一个元祖，而其子集不行，则称该属性组为候选码\n\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ii. **主码：** 选定候选码中的一个作为主码\n\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;iii. **主属性：** 候选码中的所有属性\n\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;iv. **非主属性/非码属性：** 主属性外的其它属性\n\n&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;v. **全码：** 所有属性都是主属性\n\n\n<br/>\n\n## 4. 基本关系（面向实际应用）\n\n&emsp;**a. 关系分为三种类型**\n\n\n&emsp;&emsp;（1）**基本关系/基本表/基表：** 即实际存储数据的逻辑结构表示，是实际存储数据的逻辑表示\n\n&emsp;&emsp;（2）**查询表：** 一定是经过查询操作所产生的结果，也是一张表，其关键字就是查询，非查询得来的表不是查询表\n\n&emsp;&emsp;（3）**视图表：** 由基本表或视图表导出，虚表，不对应实际的存储数据\n\n&emsp;**b. 基本关系的六大性质**\n\n &emsp;&emsp;&emsp;（一）前两个个性质简称为”列的同质不同名“：\n\n&emsp;&emsp;&emsp;&emsp;&emsp;（1）同质（Homogeneous）：每列中的分量都来自同一个域；\n\n&emsp;&emsp;&emsp;&emsp;&emsp;（2）每列对应一个属性（因此某个分量，如15岁不能成为一个属性，只能成为一个分量，而年龄才能成为一个属性），而属性之间不同名；\n\n &emsp;&emsp;&emsp;（二）接下来两个性质为顺序任意性：\n\n&emsp;&emsp;&emsp;&emsp;&emsp;（3）列的顺序任意：通过属性不同名（即每列不同名）的方式改变笛卡尔积不满足交换律的性质，这符合实际需要；\n\n&emsp;&emsp;&emsp;&emsp;&emsp;（4）行的顺序任意：即元组顺序任意；\n\n &emsp;&emsp;&emsp;（三） 主码互斥性质：\n\n&emsp;&emsp;&emsp;&emsp;&emsp;（5）任意两个元组的主码的值不能相等，否则和主码唯一标识一个元组的定义相矛盾；\n\n &emsp;&emsp;&emsp;（四）范式（Normal Form）的基本——禁止”表中表“：\n\n&emsp;&emsp;&emsp;&emsp;&emsp;（6）分量必须为原子量，不可再分为其它关系二维表；\n\n\n注：范式就是规范的关系，规范化要求关系满足一些基本条件以避免一些在关系操作中出现一些致命的错误；\n\n！！注意：实际关系数据库产品中有些并不完全支持以上6条性质，有些对行和列的顺序敏感等；\n","tags":["MYSQL"],"categories":["MYSQL"]},{"title":"HTML总结","url":"/2019/02/28/HTML/","content":"\n---\n\n<!--more-->\n\n# **HTML**\n\n### HTML标准页面内容\n\n```html\n<!DOCTYPE html>\n  <!--\n    1. 上面是一个文档声明\n    2. 根标签 html\n    3. html文件主要包含两部分. 头部分和体部分\n      头部分 : 主要是用来放置一些页面信息\n      体部分 : 主要来放置我们的HTML页面内容\n    4. 通过标签来对内容进行描述,标签通常都是由开始标签和结束标签组成\n    5. 标签不区分大小写, 官方建议使用小写\n  -->\n<html>\n  <head>\n    <!--指定页面打开编码方式-->\n    <meta charset=\"UTF-8\">\n    <!--指定页面内容-->\n    <title>哈哈哈</title>\n  </head>\n    <body>\n      <p>哈哈哈</p>\n    </body>\n<html>\n```\n\n### 各种常见标签及属性、\n\n#### 显示类标签\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <!--指定页面打开编码方式-->\n    <meta charset=\"UTF-8\">\n    <!--指定页面内容-->\n    <title>哈哈哈</title>\n  </head>\n  <body>\n    <h1>标题标签</h1>\n    <p>段落标签</p>\n    <font color=\"aqua\" size=\"4\" face=\"宋体\">字体标签</font><br />\n    <b>加粗</b><br /><!--换行-->\n    <i>斜体</i><br />\n    <b><i>加粗And斜体</i></b><br /><!--标签可以嵌套-->\n    <strong>加粗（带语气标签）</strong><br />\n    <em>斜体（带语气标签）</em><br />\n  </body>\n</html>\n```\n\n#### 图片标签\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>哈哈哈</title>\n  </head>\n    <body>\n      <!--\n        img常用属性:\n          src : 指定图片路径\n          width : 指定图片宽度\n          height : 图片高度\n          alt : 文件加载失败时的提示信息\n      -->\n      <img src=\"../../xxx.jpg\" width=\"500px\" alt=\"图片加载失败\" />\n    </body>\n<html>\n```\n\n#### 链接标签\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>哈哈哈</title>\n  </head>\n    <body>\n      <!--\n        点击链接,跳转去指定网站\n        <a>超链接标签\n          常用的属性:\n            href:指定要跳转去的链接地址\n               如果是网络地址需要加上http协议 ,\n               如果访问的是本网站的html文件,可以直接写文件路径\n            target:以什么方式打开\n               _self:默认打开方式,在当前窗口打开\n               _blank:新起一个标签页打开页面\n      -->\n\n      <a href=\"http://www.baidu.com\" target=\"_blank\">百度</a>\n    </body>\n<html>\n````\n\n#### 列表标签\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>哈哈哈</title>\n  </head>\n  <body>\n      <!--\n        使用无序列表<ul><ul>\n        属性：type：小圆圈，小圆点，小方块\n\n        使用有序列表<ol></ol>\n        属性：type：1，a，A，i，I\n             start：指定起始索引\n      -->\n      <ul type=\"disc\">\n        <li>xxx</li>\n        <li>yyy</li>\n        <li>zzz</li>\n      </ul>\n      <ol type=\"A\" start=\"2\">\n        <li>xxx</li>\n        <li>yyy</li>\n        <li>zzz</li>\n      </ol>\n  </body>\n<html>\n````\n\n#### 表格标签\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>哈哈哈</title>\n  </head>\n  <body>\n    <!--\n      <table>标签:\n        常用的属性:\n          border:指定边框\n          bgcolor:背景色\n          width:宽度\n          height:高度\n          align:对齐方式\n      <tr> 标签\n      <td> 标签\n    合并单元格:\n      colspan:跨列操作\n      rowspan:跨行操作\n      注意:跨行或者跨列操作之后,被占掉的格子需要删除掉\n    表格的嵌套:\n      在td中可以嵌套一个表格\n    -->\n    <table border=\"1px\" bgcolor=\"aqua\" width=\"500px\" height=\"500px\" align=\"center\">\n      <tr>\n        <td colspan=\"2\">1</td>\n        <td>2</td>\n        <td>3</td>\n        <td>4</td>\n      </tr>\n      <tr>\n        <td rowspan=\"2\">5</td>\n        <td>6</td>\n        <td>7</td>\n        <td>8</td>\n        <td>9</td>\n      </tr>\n      <tr>\n        <td>10</td>\n        <td colspan=\"2\" rowspan=\"2\">\n          <!--table嵌套-->\n          <table border=\"1px\" width=\"100%\" height=\"100%\" align=\"center\">\n            <tr>\n              <td>a</td>\n              <td>b</td>\n              <td>c</td>\n            </tr>\n            <tr>\n              <td>d</td>\n              <td>e</td>\n              <td>f</td>\n            </tr>\n            <tr>\n              <td>g</td>\n              <td>h</td>\n              <td>i</td>\n            </tr>\n          </table>\n        </td>\n        <td>12</td>\n      </tr>\n      <tr>\n        <td>13</td>\n        <td>14</td>\n        <td>15</td>\n      </tr>\n      <tr>\n        <td>16</td>\n        <td>17</td>\n        <td>18</td>\n        <td>19</td>\n        <td>20</td>\n      </tr>\n    </table>\n  </body>\n<html>\n````\n\n#### 注册标签\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>哈哈哈</title>\n  </head>\n  <body>\n    <!--\n      表单标签\n        action:直接提交的地址\n        method:\n          get 方式  默认提交方式 ,会将参数拼接在链接后面 , 有大小限制 ,4k\n          post 方式  会将参数封装在请求体中, 没有这样的限制\n        input:\n          type:指定输入项的类型\n            text:文本\n            password:密码框\n            radio:单选按钮\n            checkbox:复选框\n            file:上传文件\n            submit:提交按钮\n            button:普通按钮\n            reset:重置按钮\n            hidden:隐藏域\n\n            date:日期类型\n            tel:手机号\n            number:只允许输入数字\n\n        placeholder:指定默认的提示信息\n        name:在表单提交的时候,当作参数的名称\n        id:给输入项取一个名字, 以便于后期我们去找到它,并且操作它\n\n      textarea:文本域, 可以输入一段文本\n        cols:指定宽度\n        rows:指定的是高度\n\n      select:下拉列表\n        option:选择项\n    -->\n    <form action=\"#\" method=\"post\">\n      <table border=\"1px\">\n        <tr>\n            <td>用户名：</td>\n            <td><input type=\"text\" placeholder=\"请输入用户名\"/></td>\n        </tr>\n        <tr>\n            <td>密码：</td>\n            <td><input type=\"password\" placeholder=\"请输入密码\"/></td>\n        </tr>\n        <tr>\n            <td>确认密码：</td>\n            <td><input type=\"password\" placeholder=\"请再次输入密码\"/></td>\n        </tr>\n        <tr>\n            <td>Email：</td>\n            <td><input type=\"email\" placeholder=\"请输入邮箱\"/></td>\n        </tr>\n        <tr>\n            <td>姓名：</td>\n            <td><input type=\"text\" placeholder=\"请输入姓名\"/></td>\n        </tr>\n        <tr>\n            <td>性别：</td>\n            <td>\n                <input type=\"radio\" name=\"sex\"/>男\n                <input type=\"radio\" name=\"sex\"/>女\n            </td>\n        </tr>\n        <tr>\n            <td>兴趣爱好：</td>\n            <td>\n                <input type=\"checkbox\" name=\"hobby\"/>篮球\n                <input type=\"checkbox\" name=\"hobby\"/>足球\n                <input type=\"checkbox\" name=\"hobby\"/>排球\n                <input type=\"checkbox\" name=\"hobby\"/>网球\n            </td>\n        </tr>\n        <tr>\n            <td>出生日期：</td>\n            <td><input type=\"date\"/></td>\n        </tr>\n        <tr>\n            <td>验证码：</td>\n            <td><input type=\"text\"/></td>\n        </tr>\n        <tr>\n            <td colspan=\"2\"><input type=\"file\"/></td>\n        </tr>\n        <tr>\n            <td colspan=\"2\" align=\"center\">\n                <textarea cols=\"33px\" rows=\"4px\"></textarea>\n            </td>\n        </tr>\n        <tr>\n            <td colspan=\"2\" align=\"center\"><input type=\"submit\" value=\"提交\"/></td>\n        </tr>\n      </table>\n    </form>\n  </body>\n</html>\n```\n","tags":["HTML"],"categories":["HTML"]},{"title":"Pygame","url":"/2019/02/28/game/","content":"\n---\n\n<!--more-->\n\n# Python--Dungeon Game #\n\n\n----------\n\n# 一：游戏介绍 #\n----------\n\n 　　利用所学的知识，写出了一个RPG类的游戏Dungeon Game，和大多数具有逼真的图像的和动画的现代RPG不同，我的RPG是向过去的游戏致敬，。在计算机发展的早期，创意故事讲述者必须使用文字来描述一个虚拟的世界。\n\n\n\n# 二：功能及实现 #\n-------\n\n\n## 1. 游戏简介 ##\n\n 　　语言：python，pygame\n\n## 2. 回顾经典的Dungeon RPG ##\n\n 　　当今主要的PRG游戏，对于20世纪80年代早期的开发者来说，都是难以置信的，那时候，个人电脑才刚刚开始普及。但是，技术并没有阻挡有想象力的故事讲述者的脚步，他们仍然想要在计算机中为玩家创建探求乐趣的世界，尽管技术水平很有限。那个时候，基于文本的显示并不被认为是糟糕或者粗糙的技术。那只不过是可用的技术。那时候，游戏开发者被计算机所迷住。\n\n## 3. 游戏内容 ##\n\n 1. 创建一个地下城\n 2. 填充地下城\n 3. 高级游戏逻辑\n\n\n## 4.具体实现 ##\n\n **一. 创建一个地下城**\n\n  　　首先，构成地下城的全是ASCII码。把所有的ASCII码看成精灵组，根据剧情需要，将之打印出来，最后形成界面。这所以这样，就是为了致敬当初的经典，一点小小的私心，嘻嘻嘻......\n\n   　**1. 生成随机的房间**\n\n 　　Rouge类游戏的一个显著的特征，就是值得不断地重复玩，因为游戏的关卡是随机生成的。每次玩游戏的时候，游戏都是不同的。要生成一个单独的关卡，要向其中填充房间。现在设计的是，一个关卡中有8个房间，上面四个，下面四个，当然也可以有其他的方式。\n\n   　  　**创建Dungeon类**\n\n 　　我们需要一个类来完成地下城的构建工作。这个类把它叫做Dungeon，它有两个辅助函数：getCharAt()和setCharAt()。我，我们利用这些函数来生成一个随机的关卡。\n\n```python\nclass Dungeon():\ndef __init__(self):\n    #create the font sprite\n    self.text = MySprite()\n    self.text.load(\"ascii8x12.png\", 8, 12, 32)\n\n    #create the level list\n    self.tiles = list()\n    for n in range(0,80*45):\n        self.tiles.append(-1)\n\ndef getCharAt(self, x, y):\n    index = y * 80 + x\n    return self.tiles[index]\n\ndef setCharAt(self, x, y, char):\n    index = y * 80 + x\n    self.tiles[index] = char\n\ndef draw(self, surface):\n    for y in range(0,45):\n        for x in range(0,80):\n            value = self.getCharAt(x,y)\n            if value >= 0:\n                slef.text.X = offx + x * 8\n\t\t\t\tself.text.Y = offy + y * 12\n    \t\t\tself.text.frame = value\n    \t\t\tself.text.last_frame = value\n    \t\t\tself.text.update(0)\n    \t\t\tself.text.draw(surface)\n```\n\n 　　现在，每次按下空格键的时候，原型都只是生成随机的关卡。为了生成房间，我们使用一个矩形来表示每个房间，并且用一个列表把房间转换成易于管理的数组。有以下3个主要的ASCII代码将用来构建一个地下城关卡：\n\n```python\n1.Code 175, char:░(brckgroud)\n2.Code 177, char:▓(hallways)\n3.Code 218, char:█(rooms)\n```\n\n   　  　**生成北面和南面的房间**\n\n  　从关卡的最顶部开始，我们将在这里放置4个房间。每个房间都有一个略微随机的位置和略微随机的大小。在创建了房间之后，Dungeon.generate()方法会用房间数据来填充贴图的数组或者列表。\n\n~~~python\ndef createRoom(self, x, y, rposx, rposy, rsizel, rsizeh):\n\troom = Rect(x + random.randint(1, rposx),\n\t\t\t\ty + random.randint(1, rposy),\n\t\t\t\trandom.randint(rsizel, raizeh),\n\t\t\t\trandom.randint(rsizel, rsizeh))\n\tself.rooms.append(room)\n\ndef generate(self, emptyChar=175, roomChar=218, hallChar=177):\n\t#clear existing levle\n\tfor index in range(0,80*45):\n\t\tself.titles(index) = emptyChar\n\n\t#create random rooms\n\tself.room = list()\n\tPL = 4\n\tPH = 8\n\tSL = 5\n\tSH = 14\n\tself.rooms = list()\n\tself.createRoom(0, 0, PL, PH, SL, SH)\n\tself.CreateRoom(24, 0, PL, PH, SL, SH)\n\tself.CreateRoom(40, 0, PL, PH, SL, SH)\n\tself.createRoom(60, 0, PL, PH, SL, SH)\n\tself.CreateRoom(0, 22, PL, PH, SL, SH)\n\tself.CreateRoom(20, 22, PL, PH, SL, SH)\n\tself.createRoom(40, 22, PL, PH, SL, SH)\n\tself.CreateRoom(60, 22, PL, PH, SL, SH)\n~~~\n\n![](https://i.imgur.com/IUpMoOK.jpg)\n\n  　**2. 生成随机的通道**\n\n 　　通道连接着房间，并且通道是进入随机关卡的关键。为了生成通道，我们要做一些Rouge类游戏所没有的假设。换句话说，从关卡中的任意一个房间连接到另一个房间。\n\n  　  　*水平通道*\n\n 　　我们规划通道代码的时候，首先就把可复用性牢记于心。首先，我们有了源房间。沿着该房间的右边界，选取一个随机的位置作为通道的起点。然后，将通道向右移动，每次移动一个贴图，直到它达到了目标房间的位置。如果我们已经碰到了目标房间，那么就这样，通道就结束了。但是，更可能的情况是，通道需要向上或者向下，才能到达一个房间。因此，如果房间的位置在下方或上方我们需要相应的让通道也向上或向下，直到到达房间。\n\n 　　下面是不需要拐弯和需要拐弯的情况。\n\n```python\ndef createHallRight(self, src, dst, hallChar):\n\tpathx = src.x + src.width\n\tpathy = src.y + random.randint(1, src.hight - 2)\n\tself.setCharAt(pathx, pathy, hallChar)\n\tif pathy > dst.y and pathy < dst.y + dst.height:\n\t\twhile pathx < dst.x:\n\t\t\tpathx += 1\n\t\t\tself.setCharAt(pathx, pathy, hallChar)\n\telse:\n\t\twhile pathx < dst.x + 1:\n\t\t\tpathx += 1\n\t\t\tself.setCharAt(pathx, pathy, hallChar)\n\t\t\tif pathy < dst.y + 1:\n\t\t\t\tself.setChatAt(pathx, pathy, hallChar)\n\t\t\t\twhile pathy < dst.y:\n\t\t\t\t\tpathy += 1\n\t\t\t\t\tself.setChatAt(pathx, pathy, hallChar)\n\t\t\telse:\n\t\t\t\tself setChatAt(pathx, pathy, hallChar)\n\t\t\t\twhile pathy > dst.y + dst.height:\n\t\t\t\t\tpathy -= 1\n\t\t\t\t\tself.setCharAt(pathx, pathy, hallChar)\n```\n\n 　　由于3个通道连接了4个房间，我们一共创建了6个通道。\n\n```python\nself.createHallRight(self.room[0], self.room[1], hallChar)\nself.createHallRight(self.room[1], self.room[2], hallChar)\nself.createHallRight(self.room[2], self.room[3], hallChar)\nself.createHallRight(self.room[4], self.room[5], hallChar)\nself.createHallRight(self.room[5], self.room[6], hallChar)\nself.createHallRight(self.room[6], self.room[7], hallChar)\n```\n\n ![](https://i.imgur.com/sB3iSvB.jpg)\n\n\n  　  　*垂直通道*\n\n 　　现在，我们已经把北面的房间和南面的房间彼此连接，但是，北面和南面这两边还没有连接起来。为此，我们还需要垂直通道，我们只需要一条垂直通道，否则，打通关卡就太容易。我们通过选取一个随机房间来做到这一点，从而使得每次这个通道都是不同的。\n\n```python\ndef createHallDown(self,src,dst,hallChar):\n    pathx = src.x + random.randint(1,src.width-2)\n    pathy = src.y + src.height\n    self.setCharAt(pathx,pathy,hallChar)\n    if pathx > dst.x and pathx < dst.x + dst.width:\n        while pathy < dst.y:\n            pathy += 1\n            self.setCharAt(pathx,pathy,hallChar)\n    else:\n        while pathy < dst.y+1:\n            pathy += 1\n            self.setCharAt(pathx,pathy,hallChar)\n        if pathx < dst.x+1:\n            self.setCharAt(pathx,pathy,hallChar)\n            while pathx < dst.x:\n                pathx += 1\n                self.setCharAt(pathx,pathy,hallChar)\n        else:\n            self.setCharAt(pathx,pathy,hallChar)\n            while pathx > dst.x + dst.width:\n                pathx -= 1\n                self.setCharAt(pathx,pathy,hallChar)\n```\n\n#到此为止，我们已经把地下城的轮廓大致的制作出来了#\n\n![](https://i.imgur.com/G9EWOc0.png)\n\n\n\n **二. 填充地下城**\n\n 　　我采用填充地下城的方式是，将东西放到贴图数组中，以便在该位置显示一个ASCII字符。然后玩家可以根据ASCII代码与它交互。如果这个代码表示财宝，那么玩家会捡起它。如果这个代码表示出口，那么玩家会向它移动。如果是一个怪兽，玩家会与之战斗。\n\n 　　**1. 添加入口和出口**\n\n 　　入口将会是某个房间的一个贴图，它可以将玩家送回到之前的关卡中。我们想要在一个房间中定位入口的位置，以便玩家能够从该位置开始。如果出口不在同一个房间中，这是最好的，否则的话，玩家可以快速的跳过整个关卡。首先我们将选择一个随机的房间，然后将出口定位在该房间的中央的位置。\n\n```python\n\tchoice -= random.randint(0, 7)\n\tself.entrance_x = self.rooms[choice].x + self.rooms[choice].width/2\n\tself.entrance_y = self.rooms[choice].y + self.rooms[choice].height/2\n\tself.setCharAt(x, y, 29) #entry portal\n\tprint(\"entrance:\", choice, x, y)\n```\n\n 　　我们为入口使用类变量，以便能够更容易的记录它，从而定位玩家。出口将会是该关卡中一个随机的位置贴图，它会把玩家带到下一个关卡中。在经典的Rouge游戏中，目标是到达最后一个关卡并且找到Amulet of Yendor，然后再原路返回。\n\n```python\nchoice2 = random.randint(0, 7)\nwhile choice2 == choice:\n\tchoice2 = random.randint(0, 7)\nx = self.rooms[choice2].x + self.rooms[choice2].width/2\ny = self.rooms[choice2].y + self.rooms[choice2].height/2\nself.setCharAt(x, y, 30) #exit portal\nprint(\"exit:\", choice2, x, y)\n\n```\n 　　我们新的入口和出口代码最终结果如下图所示。入口看上去是一个“向上”的箭头，而出口看上去像是一个“向下”的箭头。\n\n![](https://i.imgur.com/bmiWrDR.png)\n\n 　　**2. 添加金子**\n\n 　　我们遵从老式的Rouge类游戏的做法，使用“G”来表示金子，要在整个关卡中添加随机的金子，只要选择一个随机的位置，检查以确保它不是一个实心的墙壁。\n\n```python\ndrops = random.randint(5, 20)\nfor n in range(i, drops):\n\ttile = 175\n\twhile(tile == 175):\n\t\tx = random.randint(0, 79)\n\t\ty = random.randint(0, 44)\n\t\ttile = self.getCharAt(x, y)\n\tself.setCharAt(x, y, 70)\n```\n\n![](https://i.imgur.com/szn6Aer.png)\n\n 　　**3. 添加武器，盔甲和生命值**\n\n 　　除了金子，我们还想给玩家放置一些随机的物品，以便让地下城看上去像是之前被探索过的，从而使其有一点特点。通常每个关卡中只有一个或两个武器或盔甲。在一些游戏中，当杀死怪兽之后，它们会留下物品。使用上面给出的为关卡添加金子的代码，我们可以用相同的方法将任何想要添加的物品添加到关卡中。我们给关卡添加一个“W”和一个“A”，分别表示一件武器和盔甲；还有两个“H”表示生命值。\n\n 　　放置物品的代码，与放置金子的代码是相同的，我们再次有一些代码放入可复用的方法中。\n\n```python\ndef putCharInRandomRoom(self, targetChar, itemChar):\n\ttile = 0\n\twhile tile != targetChar:\n\t\tx = random.randint(0, 79)\n\t\ty = random.randint(0, 44)\n\t\ttile = self.getCharAt(x, y)\n\tself.setCharAt(x, y, itemChar)\n\nself.putCharInRandomRoom(roomChar, 86) #'W'\nself.putCharInRandomRoom(roomChar, 64) #'A'\nself.putCharInRandomRoom(roomChar, 71) #'H'\nself.putCharInRandomRoom(roomChar, 71) #'H'\n```\n\n 　　**4. 添加怪兽**\n\n 　　我们需要一个很好，强壮的对手，以使得故事更为有趣。怪兽可以用任何的ASCII码表示。当玩家遇到怪兽的时候，其所有的信息都是临时产生的。\n\n```python\nnum = random.randint(5, 10)\nfor n in range(0, num):\n\tself.putCharInrandomRoom(roonChar, 20)\n```\n\n 　　**5. 添加玩家**\n\n 　　我们还需要一个PC，它不只是添加到地下城那么简单，还要有单独的变量来维护它。毕竟，我们必须记录玩家的状态。通过一个定制的Player类来做到这一点。游戏开始的时候，通常玩家可以参与“滚动”角色的状态。玩家变量将是全局的，而不是Dungeon类的一部分。\n\n```python\ndungeon.generate()\nplayer.x = dungeon.entrance_x + 1\nplayer.y = dungeon.entrance_y + 1\n```\n\n 　　 　**移动玩家角色**\n\n 　　现在，我们已经做好了足够的准备，可以移动和绘制玩家角色了。在主程序的事件处理程序中，我们将响应键盘按下事件，以便移动玩家角色。所发生的事情是，我们试图向4个方向中的某一个来移动玩家。如果该方向被房间或者通道代码以外的任何代码其他代码所阻塞，那么，这是一个对象，我们应该对其做出响应，然后再移动过去。\n\n```python\nif event.key == K_ESCAPE: sys.exit()\n\nelif event.key == K_SPACE:\n\tdungeon.generate(TILE_EMPTY,TILE_ROOM,TILE_HALL)\n\tplayer.x = dungeon.entrance_x+1\n\tplayer.y = dungeon.entrance_y+1\n\nelif event.key==K_UP or event.key==K_w:\n\tif player.moveUp() == False:\n\t\tplayerCollision(0,-1)\n\nelif event.key==K_DOWN or event.key==K_s:\n\tif player.moveDown() == False:\n\t\tplayerCollision(0,1)\n    elif event.key==K_RIGHT or event.key==K_d:\n\t\tif player.moveRight() == False:\n\t\t\tplayerCollision(1,0)\n    elif event.key==K_LEFT or event.key==K_a:\n\t\tif player.moveLeft() == False:\n\t\t\tplayerCollision(-1,0)\n```\n\n 　　当按下向上，向下，向左，向右键的时候，我们通常调用Player.MoveUp()，Player.MoveDown()等方法来模拟在该方向上的移动。如果移动是合法的，这些方法将会返回True，否则返回False。\n\n\n **三. 高级游戏逻辑**\n\n 　　这个高级游戏逻辑给游戏带来生机，包括战斗，可见性，物品捡拾，A.I.移动\n\n\n 　　 **捡拾物品**\n\n 　　玩家有一个攻击和防御值可以用于与怪兽战斗。当在地下城中捡拾到一件武器或者盔甲的时候，如果该物品比当前所拥有的物品好的时候，自动装备它。否则，转换成金子。\n\n 下面是捡拾金子的示例：\n\n```python\ndef playerCollision(stepx,stepy):\n\tglobal TILE_EMPTY,TILE_ROOM,TILE_HALL,dungeon,player,level\n\tyellow = (220,220,0)\n\tgreen = (0,220,0)\n\n\t#get object at location\n\tchar = dungeon.getCharAt(player.x + stepx, player.y + stepy)\n\n\tif char == 29: #portal up\n    \tmessage(\"portal up\")\n\n\telif char == 30: #portal down\n    \tmessage(\"portal down\")\n\n\telif char == TILE_EMPTY: #wall\n    \tmessage(\"You ran into the wall--ouch!\")\n\n\telif char == 70: #gold\n    \tgold = random.randint(1,level)\n    \tplayer.gold += gold\n    \tdungeon.setCharAt(player.x+stepx, player.y+stepy, TILE_ROOM)\n    \tmessage(\"You found \" + str(gold) + \" gold!\", yellow)\n```\n\n要处理武器，我们需要查找用于武器放置的ASCII代码，。在Dungeon类中，这是一个“W”字符，其ASCII代码是86。当玩家捡拾起一个“W”的时候，我们讲编写一些代码，给玩家一款随机的，新的武器：\n\n```python\nelif char == 86: #weapon\n    weapon = random.randint(1,level+2)\n    if level <= 5: #low levels get crappy stuff\n        temp = random.randint(0,2)\n    else:\n        temp = random.randint(3,6)\n    if temp == 0: name = \"Dagger\"\n    elif temp == 1: name = \"Short Sword\"\n    elif temp == 2: name = \"Wooden Club\"\n    elif temp == 3: name = \"Long Sword\"\n    elif temp == 4: name = \"War Hammer\"\n    elif temp == 5: name = \"Battle Axe\"\n    elif temp == 6: name = \"Halberd\"\n    if weapon >= player.weapon:\n        player.weapon = weapon\n        player.weapon_name = name\n        message(\"You found a \" + name + \" +\" + str(weapon) + \"!\",yellow)\n    else:\n        player.gold += 1\n        message(\"You discarded a worthless \" + name + \".\")\n    dungeon.setCharAt(player.x+stepx, player.y+stepy, TILE_ROOM)\n```\n\n\n\n我们将使用类似的代码处理盔甲的捡拾。盔甲物品的捡拾字符是“A”，ASCII代码是64：\n\n```python\nelif char == 64: #armor\n    armor = random.randint(1,level+2)\n    if level <= 5: #low levels get crappy stuff\n        temp = random.randint(0,2)\n    else:\n        temp = random.randint(3,7)\n    if temp == 0: name = \"Cloth\"\n    elif temp == 1: name = \"Patchwork\"\n    elif temp == 2: name = \"Leather\"\n    elif temp == 3: name = \"Chain\"\n    elif temp == 4: name = \"Scale\"\n    elif temp == 5: name = \"Plate\"\n    elif temp == 6: name = \"Mithril\"\n    elif temp == 7: name = \"Adamantium\"\n    if armor >= player.armor:\n        player.armor = armor\n        player.armor_name = name\n        message(\"You found a \" + name + \" +\" + str(armor) + \"!\",yellow)\n    else:\n        player.gold += 1\n        message(\"You discarded a worthless \" + name + \".\")\n    dungeon.setCharAt(player.x+stepx, player.y+stepy, TILE_ROOM)\n```\n\n最后我们还要捡拾治疗药剂，字符是“H”，ASCII代码是71：\n\n```python\nelif char == 71: #health\n    heal = 0\n    for n in range(0,level):\n        heal += Die(6)\n    player.addHealth(heal)\n    dungeon.setCharAt(player.x+stepx, player.y+stepy, TILE_ROOM)\n    message(\"You drank a healing potion worth \" + str(heal) + \\\n        \" points!\", green)\n```\n\n 　　 **与怪兽战斗**\n\n 　　在大多数的RPG游戏中，战斗都遵循非常具体的规则，我们将模拟这个过程。线代RPG游戏中，对战斗的基本假设可能与Rouge中的做法不同，但将竭尽全力让战斗变得有趣。战斗中涉及以下3个因素：\n\n\t1：防守者的防守者\n\t2：攻击者的攻击值\n\t3：攻击者的毁灭值\n\n **计算防御值**\n\n 要计算一次的攻击所使用的防御值，我们使用如下的公式：\n\n\tDefense = DEXTERITY + Armor Value\n\n **计算攻击值**\n\n 计算攻击值的公式如下：\n\n\tAttack = STRENGHT + D20\n\n“D20”的意思是滚动一个有20面的色子。用那么多面的色子，是的攻击值有一个很广的范围。这可以反映出战斗的不同效果，其中一些攻击完全忽略，另一些则击中了敌人。我们将攻击值与怪兽的防御值进行比较。如果攻击值大于防御值，那么，“攻击”成功。接下来计算毁灭值。\n\n **计算毁灭值**\n\n 如果攻击成功，那么，防御者会遭到损失。损失的程度根据如下的公式计算。\n\n\tDamage = D8 + STRENGTH + Weapon Damage - Defense\n\n具体的代码：\n\n```python\ndef attack_monster(x,y,char):\nglobal dungeon, TILE_ROOM\n\nmonster = Monster(dungeon,level,\"Grue\")\n\n#player's attack\ndefense = monster.getDefense()\nattack = player.getAttack()\ndamage = player.getDamage(defense)\nbattle_text = \"You hit the \" + monster.name + \" for \"\nif attack == 20 + player.str: #critical hit?\n    damage *= 2\n    battle_text += str(damage) + \" CRIT points!\"\n    dungeon.setCharAt(x, y, 70) #drop gold\nelif attack > defense: #to-hit?\n    if damage > 0:\n        battle_text += str(damage) + \" points.\"\n        dungeon.setCharAt(x, y, 70) #drop gold\n    else:\n        battle_text += \"no damage!\"\n        damage = 0\nelse:\n    battle_text = \"You missed the \" + monster.name + \"!\"\n    damage = 0\n\n#monster's attack\ndefense = player.getDefense()\nattack = monster.getAttack()\ndamage = monster.getDamage(defense)\nif attack > defense: #to-hit?\n    if damage > 0:\n        #if damage is overwhelming, halve it\n        if damage > player.max_health: damage /= 2\n        battle_text += \" It hit you for \" + str(damage) + \" points.\"\n        player.addHealth(-damage)\n    else:\n        battle_text += \" It no damage to you.\"\nelse:\n    battle_text += \" It missed you.\"\n\n#display battle results\nmessage(battle_text)\n\n#did the player survive?\nif player.health <= 0: player.alive = False\n```\n\n 　　 **移动怪兽**\n\n```python\ndef move_monsters():\n\t#find monsters\n\tfor y in range(0,44):\n    for x in range(0,79):\n        tile = dungeon.getCharAt(x,y)\n        if tile == 20: #monster?\n            move_monster(x,y,20)\n\ndef move_monster(x,y,char):\n\tglobal TILE_ROOM\n\tmovex = 0\n\tmovey = 0\n\tdir = random.randint(1,4)\n\tif dir == 1: movey = -1\n\telif dir == 2: movey = 1\n\telif dir == 3: movex = -1\n\telif dir == 4: movex = 1\n\tc = dungeon.getCharAt(x + movex, y + movey)\n\tif c == TILE_ROOM:\n    \tdungeon.setCharAt(x, y, TILE_ROOM) #delete old position\n    \tdungeon.setCharAt(x+movex, y+movey, char) #move to new position\n```\n\n\n\n 　　 **可见性范围**\n\n```python\ndef draw_radius(self, surface, rx, ry, radius):\n    left = rx - radius\n    if left < 0: left = 0\n    top = ry - radius\n    if top < 0: top = 0\n    right = rx + radius\n    if right > 79: right = 79\n    bottom = ry + radius\n    if bottom > 44: bottom = 44\n        for y in range(top,bottom):\n        \tfor x in range(left,right):\n            \tchar = self.getCharAt(x,y)\n            \tif char >= 0 and char <= 255:\n                \tself.draw_char(surface, x, y, char)\n```\n![](https://i.imgur.com/U4Cf9lS.png)\n\n\n\n 　　 **游戏结束**\n\n 　　 当玩家的生命值为0时，游戏结束！！！\n","tags":["Pygame"],"categories":["答辩"]},{"title":"Atom的安装以及配置","url":"/2019/02/28/Atom/","content":"\n---\n\n<!--more-->\n\n# 使用Atom打造无懈可击的Markdown编辑器\n\n一直以来都奢想拥有一款全能好用的Markdown编辑器，直到遇到了Atom。废话不多说，直接开搞！\n\n### 1. 安装Atom\n\n下载安装Atom: [https://atom.io/](https://atom.io/)\n\n### 2. 增强预览(markdown-preview-plus)\nAtom自带的Markdown预览插件markdown-preview功能比较简单，markdown-preview-plus对其做了功能扩展和增强。\n\n1. 支持预览实时渲染。(Ctrl + Shift + M)\n2. 支持Latex公式。(Ctrl + Shift + X)\n\n使用该插件前，需要先禁用markdown-preview。\n\n![image](http://ww1.sinaimg.cn/large/0071ouepgy1g0me8r8ubzg30t80jw7a0.gif)\n\n查看实时渲染和公式编辑功能\n\n![image](http://ww1.sinaimg.cn/large/0071ouepgy1g0meacsy82g30lz06hdg3.gif)\n\n### 3. 同步滚动(markdown-scroll-sync)\n\n同步滚动是Markdown编辑器的必备功能，方便翻阅文档修改时能快速定位到预览的位置。\n\nmarkdown-scroll-sync不仅支持同步滚动，在光标位置发生变更时也会同步滚动，这个功能在很多Markdown编辑器中不具备。\n\n版本2.1.2 对应 markdown-preview-plus2.4.16\n\n参考：[博客](https://www.cnblogs.com/shileibrave/p/9924192.html)\n\n![image](http://ww1.sinaimg.cn/large/0071ouepgy1g0mefxld9ug30zm0ksqg0.gif)\n\n### 4. 代码增强(language-markdown)\n\n一般的Markdown编辑器提供了代码着色等基本功能，language-markdown除了能给代码着色，还提供了快捷的代码片段生成等功能。\n\n![image](http://ww1.sinaimg.cn/large/0071ouepgy1g0meguu97wg310j09an1d.gif)\n\n### 5. 图片粘贴(markdown-image-paste)\n\n图片功能支持的好坏直接决定了我是否选择使用一个Markdown编辑器。也有不少编辑器和在线的图床绑定，但是这种方式受限于网络。虽然Markdown支持插入本地图片，但是每次插入新图片都是一堆重复操作：截图－命名－保存－插入。markdown-image-paste将这些操作一步完成：\n\n1. 使用截图工具将图片复制到系统剪切板。\n2. 在Markdown新起一行输入文件名。\n3. Ctrl + V 会自动把图片保存到Markdown文件相同目录下(因此要求Markdown文件应该先保存)，并命名为刚输入的文件名，同时在刚才输入文件名行处生成img标签。\n\n![image](http://ww1.sinaimg.cn/large/0071ouepgy1g0mei8phs5g310j0lhgu4.gif)\n\n### 6. 表格编辑(markdown-table-editor)\n\n一直对Markdown的table语法很无爱，直到遇到了markdown-table-editor，这操作效率简直炸了！文字已经不能表达我的激动之情了，直接看图吧。\n\n![image](http://ww1.sinaimg.cn/large/0071ouepgy1g0mejpm20ng30zm0bcgmm.gif)\n\n### 7. pdf导出(markdown-pdf)\n\n不少Markdown编辑器都会提供pdf导出功能，甚至将其作为收费功能。而Atom的markdown-pdf插件可以轻松实现pdf导出和预览功能。\n\nPackages -> Markdown to PDF -> Convert\n\n\n### 8. 总结\n\n以上介绍的Atom的Markdown插件，基本上满足了我对一个Markdown编辑器的所有幻想，实时渲染、同步滚动，公式、代码、图片、表格的快捷操作与支持，以及pdf文件导出、预览等。希望此文对你有所帮助。\n","tags":["Atom"],"categories":["Atom"]}]